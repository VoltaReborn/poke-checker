<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Pok√©Type Checker</title>
<link rel="manifest" href="manifest.json" />
<style>
:root {
  --bg:#0a1224;
  --card:#15254b;
  --accent:#ffb400;
  --text:#fff;
}
/* Base */
* { box-sizing: border-box; }
body { margin:0; font-family: system-ui, Arial, sans-serif; background: var(--bg); color: var(--text); }
header { display:flex; justify-content:space-between; align-items:center; padding:10px 16px; background:var(--card); }
h1 { font-size:1.1rem; margin:0; }
#themeToggle { background:none; border:none; cursor:pointer; color:var(--accent); font-size:1.2rem; }

/* Tabs */
#modeTabs { display:flex; justify-content:center; margin:10px 0; }
.tab {
  padding:8px 16px; background:var(--card); color:var(--text);
  border:1px solid var(--accent); border-radius:8px; margin:0 5px; cursor:pointer;
}
.tab.active { background:var(--accent); color:#000; }

/* Sections & Cards */
.section { display:none; padding:10px; }
.section.active { display:block; }
.resultCard {
  background:var(--card); margin:8px 0; padding:10px;
  border:1px solid var(--accent); border-radius:8px; animation:fade .3s;
}
@keyframes fade { from{opacity:0;} to{opacity:1;} }
.type-badge {
  display:inline-block; border-radius:12px; padding:4px 8px; margin:2px;
  color:#fff; font-weight:600; font-size:.9rem;
}

/* Controls */
#typeControls, #pokeControls {
  display:flex; flex-direction:column; align-items:center; gap:10px; margin-bottom:10px;
}
select, input {
  width:90%; max-width:360px; font-size:1rem; padding:12px; border-radius:8px;
  border:1px solid var(--accent); background:var(--card); color:var(--text); text-align:center;
}
select:focus, input:focus { outline:none; box-shadow:0 0 4px var(--accent); }
#typeButtons { display:flex; justify-content:center; gap:10px; flex-wrap:wrap; }
button {
  font-size:1rem; padding:10px 14px; border-radius:8px; border:1px solid var(--accent);
  background:var(--card); color:var(--text); cursor:pointer;
}
button:hover { background:var(--accent); color:#000; }
#resetBtn, #pokeResetBtn { background:none; border:1px solid var(--accent); color:var(--accent); }
#resetBtn:hover, #pokeResetBtn:hover { background:var(--accent); color:#000; }

/* Divider */
.section-divider {
  margin:16px 0; text-align:center; font-weight:bold; color:var(--accent); position:relative;
}
.section-divider::before, .section-divider::after {
  content:""; position:absolute; top:50%; width:40%; height:1px;
  background:linear-gradient(to right,transparent,var(--accent),transparent);
}
.section-divider::before { left:0; } .section-divider::after { right:0; }

/* Previews */
#typePreview, #pokeTypePreview { display:flex; justify-content:center; gap:6px; }
.type-preview-badge { display:inline-block; width:60px; height:18px; border-radius:10px; }

/* Pok√©mon checker specifics */
#pokeImg { width:140px; display:block; margin:10px auto; }
#pokeList div { padding:6px 10px; background:var(--card); border:1px solid var(--accent);
  border-radius:8px; margin:2px 0; }
#pokeList div:hover { background:var(--accent); color:#000; }

/* Evolution UI */
#pokeButtonsRow { display:flex; justify-content:center; gap:10px; margin-top:10px; flex-wrap:wrap; }
#evoCard { background:var(--card); border:1px solid var(--accent); border-radius:12px; padding:10px; margin:10px 0; }
.evo-line { display:flex; align-items:center; justify-content:center; flex-wrap:wrap; gap:10px; }
.evo-node { text-align:center; cursor:pointer; }
.evo-node img { width:72px; height:72px; object-fit:contain; display:block; margin:0 auto 4px; }
.evo-name { font-size:.85rem; }
.evo-arrow { color:var(--accent); font-weight:700; display:flex; align-items:center; gap:6px; }
.evo-method { font-size:.75rem; opacity:.9; }

/* Responsive layout */
@media (min-width: 700px) {
  main { display:grid; grid-template-columns: 1fr 1fr; gap:12px; padding:10px; }
}

@keyframes pokePulse {
  0%   { filter: drop-shadow(0 0 6px rgba(255,180,0,0.35)); }
  50%  { filter: drop-shadow(0 0 18px rgba(255,180,0,0.75)); }
  100% { filter: drop-shadow(0 0 6px rgba(255,180,0,0.35)); }
}

/* Default: subtle placeholder (smaller, semi-transparent) */
#pokeImg{
  display:block;
  margin:10px auto;
  width:100px;
  opacity:0.55;
  transition: opacity .45s ease, width .25s ease;
}

/* Pulsing amber glow state (when showing Pok√© Ball icon) */
#pokeImg.pulse{
  animation: pokePulse 2.4s ease-in-out infinite;
}

/* Active Pok√©mon artwork (larger, fully opaque, no pulse) */
#pokeImg.active{
  width:140px;
  opacity:1;
  animation:none;
  filter:none;
}

/* === NEW FEATURES CSS (append at end) === */

/* Home screen cards */
.home-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 10px;
  margin: 10px 0;
}
.home-card {
  background: var(--card);
  border: 1px solid var(--accent);
  border-radius: 12px;
  padding: 12px;
  text-align: center;
  cursor: pointer;
  transition: transform .15s ease, box-shadow .15s ease, border-color .15s ease;
}
.home-card:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 14px rgba(0,0,0,.25);
  border-color: #ffd36a;
}
.home-card .title { font-weight: 700; margin-bottom: 6px; }
.home-card .desc { font-size: .9rem; opacity: .9; }

/* Shared layouts */
.tool-wrap { display:flex; flex-direction:column; gap:10px; align-items:center; }
.tool-row { display:flex; gap:8px; flex-wrap:wrap; justify-content:center; }
.tool-wide { width: 92%; max-width: 420px; }

/* Result grids */
.poke-grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 8px;
  width: 100%;
}
.poke-card {
  background: var(--card);
  border: 1px solid var(--accent);
  border-radius: 10px;
  padding: 8px;
  text-align: center;
  cursor: pointer;
}
.poke-card img { width: 72px; height: 72px; object-fit: contain; display:block; margin: 0 auto 4px; }
.poke-card .nm { font-size: .85rem; }

/* VS panel */
.vs-wrap { display:flex; gap:10px; flex-wrap:wrap; justify-content:center; }
.vs-col { flex: 1 1 280px; min-width: 260px; background: var(--card); border: 1px solid var(--accent); border-radius: 10px; padding: 10px; }
.vs-title { font-weight: 700; margin-bottom: 6px; }
.vs-chip { display:inline-block; margin: 2px; padding: 3px 8px; border-radius: 12px; color:#fff; font-weight:600; font-size:.85rem; }

/* Team coverage */
.team-wrap { display:flex; flex-direction:column; gap:12px; align-items:center; }
.team-bar { display:flex; gap:6px; flex-wrap:wrap; justify-content:center; }
.team-slot {
  display:flex; align-items:center; gap:8px;
  background: var(--card); border:1px solid var(--accent); border-radius:8px; padding:6px 8px;
}
.team-slot img { width:44px; height:44px; object-fit:contain; }
.team-slot .rm { background:none; border:1px solid var(--accent); color:var(--accent); padding:4px 6px; border-radius:6px; cursor:pointer; }
.team-actions { display:flex; gap:8px; flex-wrap:wrap; justify-content:center; }
.coverage-row { display:flex; gap:6px; flex-wrap:wrap; justify-content:center; }
.coverage-badge {
  display:inline-block; border-radius: 12px; padding:4px 8px; color:#fff; font-weight:700; font-size:.85rem;
}
.coverage-title { font-weight: 700; margin-top: 6px; text-align:center; }

/* Responsive tweaks */
@media(min-width: 860px){
  .home-grid { grid-template-columns: repeat(4, 1fr); }
  .poke-grid { grid-template-columns: repeat(6, 1fr); }
}

/* HOME-ONLY NAV (no top bar) */
#modeTabs { display: none !important; }

.home-btn {
  align-self: center;
  margin: 4px 0 8px;
  padding: 8px 12px;
  border-radius: 8px;
  border: 1px solid var(--accent);
  background: var(--card);
  color: var(--text);
  font-weight: 600;
  cursor: pointer;
}
.home-btn:hover {
  background: var(--accent);
  color: #000;
}

/* === MOVESET PANEL === */
.moves-panel {
  margin-top: 1rem;
  padding: 1rem;
  background: var(--card);
  border-radius: 10px;
  box-shadow: 0 0 8px rgba(255,191,0,0.25);
}

.moves-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  flex-wrap: wrap;
  margin-bottom: 0.5rem;
}

.moves-header select {
  padding: 6px 10px;
  border-radius: 6px;
  border: 1px solid var(--accent);
  background: var(--bg);
  color: var(--text);
  font-weight: 600;
}

.moves-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 0.9rem;
}

.moves-table th, .moves-table td {
  padding: 6px 8px;
  border-bottom: 1px solid rgba(255,255,255,0.1);
  text-align: left;
}

.moves-table th { color: var(--accent); }

.move-type-badge {
  display: inline-block;
  padding: 2px 6px;
  border-radius: 6px;
  font-size: 0.8em;
  margin-left: 6px;
  color: #fff;
  text-transform: capitalize;
}

.move-cat {
  display: inline-flex;
  align-items: center;
  gap: 4px;
}

.move-cat img {
  width: 16px;
  height: 16px;
}

/* category icons (Physical / Special / Status) */
.cat-icon{
  width: 20px;
  height: 20px;
  vertical-align: middle;
  filter: drop-shadow(0 0 3px rgba(10,18,36,.6));
}

/* side-by-side regular + shiny art */
#pokeArtWrap{
  display:flex;
  justify-content:center;
  align-items:center;
  gap:12px;
  flex-wrap:wrap;
}

#pokeCheckerTop img {
  position: relative;
  max-width: 140px;
  display: block;
  margin: 0 auto;
  z-index: 1;
}

#evoToggle.disabled { opacity: .5; pointer-events: none; }

.cat-wrapper {
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
}

.cat-wrapper:focus,
.cat-wrapper img:focus {
  outline: none;
}

.cat-tooltip {
  position: absolute;
  bottom: 120%;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(10, 18, 36, 0.95);
  color: #fdd066;
  border: 1px solid rgba(255, 200, 100, 0.4);
  padding: 3px 8px;
  border-radius: 6px;
  font-size: 11px;
  opacity: 0;
  pointer-events: none;
  white-space: nowrap;
  transition: opacity 0.15s ease-in-out;
  box-shadow: 0 0 6px rgba(255, 200, 100, 0.3);
}

/* Remove default pseudo tooltip ‚Äî handled entirely via JS now */
.cat-wrapper::after {
  display: none !important;
  content: none !important;
}

@keyframes hideTooltip {
  0% { opacity: 1; }
  80% { opacity: 1; }
  100% { opacity: 0; }
}

/* Team layout: full-width card, proper layering, no red bleed */
.team-bar { display: flex; flex-direction: column; gap: 10px; }

.team-slot {
  position: relative;
  width: 100%;
  border: 1px solid var(--accent);
  border-radius: 12px;
  background: var(--card);       /* card has the theme background */
  box-sizing: border-box;
  max-width: 100%;
  overflow: hidden;              /* hide rail when closed */
  padding: 0;                    /* no padding on the container */
}

/* SLIDING CONTENT sits above the rail and covers rounded corners */
.slot-content {
  position: relative;
  z-index: 1;                    /* above the rail */
  display: grid;
  grid-template-columns: auto 1fr;
  gap: 14px;
  align-items: center;
  width: 100%;                   /* fill the card */
  padding: 10px 12px;            /* move padding here */
  border-radius: inherit;        /* match the card‚Äôs rounded corners */
  background: var(--card);       /* same background as card to hide rail */
  transform: translateX(0);      /* explicitly closed */
  transition: transform .2s ease;
  will-change: transform;
  box-shadow: 1px 0 0 var(--card);
}
.team-slot.dragging .slot-content { transition: none; }

/* FIXED DELETE RAIL behind content (red) */
.slot-delete {
  position: absolute;
  top: 0; right: 0;
  height: 100%;
  width: 96px;
  display: flex; align-items: center; justify-content: center;
  background: var(--danger, #dc2626);   /* red */
  color: #fff; font-weight: 800;
  border: none;
  border-left: 1px solid rgba(0,0,0,.25);
  z-index: 0;                           /* behind content */
}

/* left side */
.slot-left { display: flex; flex-direction: column; align-items: center; gap: 6px; }
.slot-art  { width: 64px; height: 64px; object-fit: contain; }
.slot-name-line { max-width: 140px; }
.slot-name { text-align: center; font-weight: 700; white-space: normal; }

/* Right side: always fill the row */
.slot-right {
  display: grid;
  grid-template-columns: 1fr auto;   /* chips take full width, actions hug right */
  align-items: center;
  gap: 8px;
  width: 100%;                       /* ‚Üê stretch across the card */
  justify-items: stretch;            /* chips block stretches, actions keep their width */
}

/* Moves area: true 2√ó2 and full width (no max-content shrink) */
.moves-preview {
  display: grid;
  grid-template-columns: repeat(2, minmax(0, 1fr)); /* equal 2 columns that actually stretch */
  gap: 8px;
  width: 100%;
  /* remove the old max-width constraint so it can fill the slot */
}

.moves-preview[data-empty="1"] { opacity: .7; }

/* Chips: perfectly centered text (both axes) and consistent height */
.move-chip {
  display: flex;                     /* center text reliably */
  align-items: center;
  justify-content: center;
  min-height: 34px;                  /* visual consistency row-to-row */
  padding: 6px 12px;                 /* keep the pill shape */
  border-radius: 999px;
  font-size: .95rem;
  font-weight: 700;
  white-space: nowrap;
  text-align: center;                /* belt-and-suspenders centering */
}

@media (max-width: 420px) {
  .slot-right { justify-items: stretch; }
  .moves-preview { justify-content: center; }
}

</style>
</head>
<body>
<header>
  <h1>Pok√©Type Checker</h1>
  <button id="themeToggle" title="Toggle Theme">‚òÄÔ∏è</button>
</header>

<div id="modeTabs">
  <div class="tab active" data-target="typeSection">Type Checker</div>
  <div class="tab" data-target="pokeSection">Pok√©mon Checker</div>
</div>

<main>
  <!-- TYPE SECTION (both perspectives) -->
  <section id="typeSection" class="section">
    <div id="typeControls">
      <label>Type 1:
        <select id="type1"></select>
      </label>
      <label>Type 2:
        <select id="type2">
          <option value="">(none)</option>
        </select>
      </label>
      <div id="typePreview"></div>
    </div>
    <div id="typeButtons">
      <button id="checkBtn">Check Effectiveness</button>
      <button id="resetBtn">Reset Types</button>
    </div>
    <div id="typeResults"></div>
  </section>

  <!-- POK√âMON SECTION (defense-only + evolution info) -->
  <section id="pokeSection" class="section">
    <div id="pokeControls">
      <input id="pokeSearch" placeholder="Search Pok√©mon name..." autocomplete="off" />
      <div id="pokeList"></div>
      <img id="pokeImg"
        src="icon-192.png"
        alt="Pok√© Ball placeholder"
        class="pulse">
      <div id="pokeTypes"></div>
      <div id="pokeButtonsRow">
        <button id="evoToggleBtn">Show Evolution Info</button>
        <button id="pokeResetBtn">Reset Pok√©mon</button>
      </div>
      <div id="evoCard" hidden>
        <div id="evoTitle" style="font-weight:700;margin-bottom:6px;">Evolution</div>
        <div id="evoContent"></div>
      </div>
    </div>
    <div id="pokeResults"></div>
  </section>
</main>

<script>
/* ---------- VERSION CONTROL & REFRESH BUTTON ---------- */
function showPokemonImage(url){
  const img = document.getElementById("pokeImg");
  img.src = url;
  img.classList.add("active");
  img.classList.remove("pulse");
}

function hidePokemonImage(){
  const img = document.getElementById("pokeImg");
  img.src = "icon-192.png";
  img.classList.remove("active");
  img.classList.add("pulse");
}
const appVersion = "1.4.0";
const refreshButton = document.createElement("button");
refreshButton.textContent = "üîÑ Refresh App";
// show only on Home
refreshButton.id = "refreshAppBtn";

function updateRefreshVisibility(){
  const home = document.getElementById("homeSection");
  const onHome = home && home.classList && home.classList.contains("active") && !home.hidden;
  // use the actual button variable you already have
  refreshButton.style.display = onHome ? "block" : "none";
}

// set initial state (will correct as soon as tabs switch)
updateRefreshVisibility();
// ensure visibility updates whenever tabs change
(function hookRefreshVisibility(){
  if (typeof window.switchTab === "function") {
    const _switch = window.switchTab;
    window.switchTab = function(targetId){
      _switch(targetId);
      updateRefreshVisibility();
    };
  } else {
    // Fallback: watch for section visibility changes if switchTab isn't present
    const main = document.querySelector("main");
    if (main) {
      const obs = new MutationObserver(() => updateRefreshVisibility());
      obs.observe(main, { attributes:true, subtree:true, attributeFilter:["class","hidden"] });
    }
  }
})();

Object.assign(refreshButton.style, {
  position:"fixed", bottom:"10px", right:"10px", padding:"6px 10px",
  fontSize:"0.9rem", borderRadius:"8px", border:"1px solid var(--accent)",
  background:"var(--card)", color:"var(--accent)", zIndex:"9999"
});
refreshButton.onclick = () => {
  localStorage.removeItem("poketype-version");
  if ('caches' in window) caches.keys().then(keys => keys.forEach(k => caches.delete(k)));
  location.reload(true);
};
document.addEventListener("DOMContentLoaded", () => document.body.append(refreshButton));
const storedVersion = localStorage.getItem("poketype-version");
if (storedVersion && storedVersion !== appVersion) {
  if ('caches' in window) caches.keys().then(keys => keys.forEach(k => caches.delete(k)));
  localStorage.setItem("poketype-version", appVersion);
  location.reload(true);
} else if (!storedVersion) {
  localStorage.setItem("poketype-version", appVersion);
}

/* ---------- TYPE DATA ---------- */
const typeChart={
Normal:{weak:["Fighting"],resist:[],immune:["Ghost"]},
Fire:{weak:["Water","Ground","Rock"],resist:["Fire","Grass","Ice","Bug","Steel","Fairy"],immune:[]},
Water:{weak:["Electric","Grass"],resist:["Fire","Water","Ice","Steel"],immune:[]},
Electric:{weak:["Ground"],resist:["Electric","Flying","Steel"],immune:[]},
Grass:{weak:["Fire","Ice","Poison","Flying","Bug"],resist:["Water","Electric","Grass","Ground"],immune:[]},
Ice:{weak:["Fire","Fighting","Rock","Steel"],resist:["Ice"],immune:[]},
Fighting:{weak:["Flying","Psychic","Fairy"],resist:["Bug","Rock","Dark"],immune:[]},
Poison:{weak:["Ground","Psychic"],resist:["Grass","Fighting","Poison","Bug","Fairy"],immune:[]},
Ground:{weak:["Water","Grass","Ice"],resist:["Poison","Rock"],immune:["Electric"]},
Flying:{weak:["Electric","Ice","Rock"],resist:["Grass","Fighting","Bug"],immune:["Ground"]},
Psychic:{weak:["Bug","Ghost","Dark"],resist:["Fighting","Psychic"],immune:[]},
Bug:{weak:["Fire","Flying","Rock"],resist:["Grass","Fighting","Ground"],immune:[]},
Rock:{weak:["Water","Grass","Fighting","Ground","Steel"],resist:["Normal","Fire","Poison","Flying"],immune:[]},
Ghost:{weak:["Ghost","Dark"],resist:["Poison","Bug"],immune:["Normal","Fighting"]},
Dragon:{weak:["Ice","Dragon","Fairy"],resist:["Fire","Water","Electric","Grass"],immune:[]},
Dark:{weak:["Fighting","Bug","Fairy"],resist:["Ghost","Dark"],immune:["Psychic"]},
Steel:{weak:["Fire","Fighting","Ground"],resist:["Normal","Grass","Ice","Flying","Psychic","Bug","Rock","Dragon","Steel","Fairy"],immune:["Poison"]},
Fairy:{weak:["Poison","Steel"],resist:["Fighting","Bug","Dark"],immune:["Dragon"]}
};
const typeColors={Normal:"#A8A77A",Fire:"#EE8130",Water:"#6390F0",Electric:"#F7D02C",Grass:"#7AC74C",
Ice:"#96D9D6",Fighting:"#C22E28",Poison:"#A33EA1",Ground:"#E2BF65",Flying:"#A98FF3",
Psychic:"#F95587",Bug:"#A6B91A",Rock:"#B6A136",Ghost:"#735797",Dragon:"#6F35FC",
Dark:"#705746",Steel:"#B7B7CE",Fairy:"#D685AD"};
// add lowercase lookup so "fire" matches your "Fire" colors
const typeColorsLower = Object.fromEntries(
  Object.entries(typeColors).map(([k, v]) => [k.toLowerCase(), v])
);
const types=Object.keys(typeChart);
const t1=document.getElementById("type1"),t2=document.getElementById("type2");

/* Fill dropdowns (desktop shows colored options; mobile shows preview bars) */
function addTypeOptions(sel){
  types.forEach(t=>{
    const opt=new Option(t,t);
    opt.style.background=typeColors[t];
    opt.style.color="#fff";
    opt.style.fontWeight="600";
    sel.add(opt);
  });
}
addTypeOptions(t1); addTypeOptions(t2);

/* Tabs */
document.querySelectorAll(".tab").forEach(tab=>{
  tab.onclick=()=>{
    document.querySelectorAll(".tab").forEach(t=>t.classList.remove("active"));
    document.querySelectorAll(".section").forEach(s=>s.classList.remove("active"));
    tab.classList.add("active");
    document.getElementById(tab.dataset.target).classList.add("active");
  };
});

/* Theme toggle */
let lightTheme=false;
const themeBtn=document.getElementById("themeToggle");
themeBtn.onclick=()=>{
  lightTheme=!lightTheme;
  document.documentElement.style.setProperty("--bg",lightTheme?"#fff":"#0a1224");
  document.documentElement.style.setProperty("--card",lightTheme?"#f4f4f4":"#15254b");
  document.documentElement.style.setProperty("--text",lightTheme?"#000":"#fff");
  themeBtn.textContent = lightTheme ? "üåô" : "‚òÄÔ∏è";
};

/* Preview bars under selects (mobile-friendly) */
function updateTypePreview(){
  const preview=document.getElementById("typePreview");
  preview.innerHTML="";
  [t1.value,t2.value].filter(Boolean).forEach(t=>{
    const div=document.createElement("div");
    div.className="type-preview-badge";
    div.style.background=typeColors[t];
    preview.append(div);
  });
}
t1.onchange=updateTypePreview; t2.onchange=updateTypePreview;

/* Reset types */
document.getElementById("resetBtn").onclick=()=>{
  t1.selectedIndex=0; t2.selectedIndex=0;
  document.getElementById("typeResults").innerHTML="";
  updateTypePreview();
};

/* Calculations */
function calcOffense(selTypes){
  const all=Object.keys(typeChart); const result={strong:[],weak:[],immune:[]};
  all.forEach(def=>{
    let mult=1;
    selTypes.forEach(atk=>{
      if(typeChart[def].weak.includes(atk)) mult*=2;
      if(typeChart[def].resist.includes(atk)) mult*=0.5;
      if(typeChart[def].immune.includes(atk)) mult*=0;
    });
    if(mult>1) result.strong.push({type:def,mult});
    if(mult<1&&mult>0) result.weak.push({type:def,mult});
    if(mult===0) result.immune.push({type:def,mult});
  });
  return result;
}
function calcDefense(selTypes){
  const all=Object.keys(typeChart); const result={strong:[],weak:[],immune:[]};
  all.forEach(atk=>{
    let mult=1;
    selTypes.forEach(def=>{
      if(typeChart[def].weak.includes(atk)) mult*=2;
      if(typeChart[def].resist.includes(atk)) mult*=0.5;
      if(typeChart[def].immune.includes(atk)) mult*=0;
    });
    if(mult>1) result.strong.push({type:atk,mult});
    if(mult<1&&mult>0) result.weak.push({type:atk,mult});
    if(mult===0) result.immune.push({type:atk,mult});
  });
  return result;
}

/* Renderers */
function renderBoth(container,label,defense,offense){
  container.innerHTML="";
  const make=(l,d)=>{
    if(!d.length) return "";
    let html=`<div class='resultCard'><strong>${l}</strong><br>`;
    d.forEach(o=>{ html+=`<span class='type-badge' style='background:${typeColors[o.type]}'>${o.type} √ó${o.mult}</span>`; });
    return html+"</div>";
  };
  container.innerHTML+=make(`Strong Against ${label}`,defense.strong);
  container.innerHTML+=make(`Not Very Effective Against ${label}`,defense.weak);
  container.innerHTML+=make(`No Effect Against ${label}`,defense.immune);
  container.innerHTML+=`<div class='section-divider'>Counter Perspective ‚ñº</div>`;
  container.innerHTML+=make(`${label} is Strong Against`,offense.strong);
  container.innerHTML+=make(`${label} is Weak Against`,offense.weak);
  container.innerHTML+=make(`${label} has No Effect On`,offense.immune);
}
function renderDefenseOnly(container,label,defense){
  container.innerHTML="";
  const make=(l,d)=>{
    if(!d.length) return "";
    let html=`<div class='resultCard'><strong>${l}</strong><br>`;
    d.forEach(o=>{ html+=`<span class='type-badge' style='background:${typeColors[o.type]}'>${o.type} √ó${o.mult}</span>`; });
    return html+"</div>";
  };
  container.innerHTML+=make(`Strong Against ${label}`,defense.strong);
  container.innerHTML+=make(`Not Very Effective Against ${label}`,defense.weak);
  container.innerHTML+=make(`No Effect Against ${label}`,defense.immune);
}

/* Type check */
document.getElementById("checkBtn").onclick=()=>{
  const sel=[t1.value,t2.value].filter(Boolean);
  if(!sel.length) return;
  const label=sel.join(" / ");
  const def=calcDefense(sel), off=calcOffense(sel);
  renderBoth(document.getElementById("typeResults"),label,def,off);
};

/* Pok√©mon search + images */
const pokeInput=document.getElementById("pokeSearch"),
      pokeList=document.getElementById("pokeList");
let pokedata=[];
async function loadData() {
  if (pokedata.length) return;
  const res = await fetch("https://pokeapi.co/api/v2/pokemon?limit=2000");
  const list = await res.json();
  pokedata = list.results.map((p, idx) => ({
    name: title(p.name),
    id: idx + 1
  }));
}

pokeInput.addEventListener("input", async () => {
  await loadData();
  const q = pokeInput.value.toLowerCase();
  pokeList.innerHTML = "";
  if (!q) return;

  // exclude forms (names with '-') and cap to real species range
  const filtered = pokedata.filter(p =>
    p.name.toLowerCase().includes(q) &&
    !p.name.includes("-") &&
    p.id <= 1025
  );

  filtered.slice(0, 10).forEach(p => {
    const div = document.createElement("div");
    div.textContent = p.name;
    div.style.cursor = "pointer";
    div.onclick = () => selectPokeById(p.id);
    pokeList.append(div);
  });
});

/* Evolution via Pok√©API */
async function fetchSpeciesById(id){
  const res=await fetch(`https://pokeapi.co/api/v2/pokemon-species/${id}/`);
  if(!res.ok) throw new Error("species fetch failed");
  return res.json();
}
async function fetchEvolutionChain(url){
  const res=await fetch(url);
  if(!res.ok) throw new Error("evo chain fetch failed");
  return res.json();
}
// extract numeric id from a PokeAPI URL
function extractIdFromUrl(u) {
  if (!u) return null;
  const m = u.match(/\/(\d+)\/?$/);
  return m ? parseInt(m[1], 10) : null;
}
// cheap title case
function cap(s){ return s.replace(/-/g,' ').replace(/\b\w/g,c=>c.toUpperCase()); }

function buildPaths(chain){
  const paths=[];
  function dfs(node, path){
    const id=extractIdFromUrl(node.species.url);
    const current=[...path, { name:node.species.name, id, details:node.evolution_details||[] }];
    if(!node.evolves_to || node.evolves_to.length===0){ paths.push(current); return; }
    node.evolves_to.forEach(next=>dfs(next, current));
  }
  dfs(chain, []);
  return paths;
}
function formatMethod(details) {
  if (!details || !details[0]) return "";
  const d = details[0];
  const bits = [];

  if (d.trigger && d.trigger.name === "trade") return "Trade";

  if (d.trigger && d.trigger.name === "use-item" && d.item)
    return `Use ${title(d.item.name)}`;

  if (d.trigger && d.trigger.name === "level-up") {
    if (d.min_level != null) bits.push(`Lv ${d.min_level}`);
    if (d.time_of_day) bits.push(title(d.time_of_day));
    if (d.min_happiness != null) bits.push(`Happiness ${d.min_happiness}+`);
    if (d.known_move_type) bits.push(`${title(d.known_move_type.name)} move`);
    if (d.gender === 1) bits.push("‚ôÄ");
    else if (d.gender === 2) bits.push("‚ôÇ");
    if (d.location) bits.push(`@ ${title(d.location.name)}`);
    return bits.join(" ¬∑ ") || "Level up";
  }

  return title(d.trigger?.name || "");
}

function title(s){ return s.replace(/-/g," ").replace(/\b\w/g,c=>c.toUpperCase()); }
function evoImgUrl(id){ return `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/other/official-artwork/${id}.png`; }

function renderEvolution(paths){
  const container=document.getElementById("evoContent");
  container.innerHTML="";
  paths.forEach(path=>{
    const line=document.createElement("div"); line.className="evo-line";
    path.forEach((node, idx)=>{
      const nodeDiv=document.createElement("div");
      nodeDiv.className="evo-node";
      nodeDiv.innerHTML=`<img src="${evoImgUrl(node.id)}" alt="${node.name}"><div class="evo-name">${title(node.name)}</div>`;
      nodeDiv.onclick=()=>selectPokeById(node.id);
      line.append(nodeDiv);
      if(idx<path.length-1){
        const next=path[idx+1];
        const arrow=document.createElement("div"); arrow.className="evo-arrow"; arrow.textContent="‚Üí";
        const method=document.createElement("div"); method.className="evo-method"; method.textContent=formatMethod(next.details);
        const wrap=document.createElement("div"); wrap.style.display="flex"; wrap.style.flexDirection="column"; wrap.style.alignItems="center";
        wrap.append(arrow); wrap.append(method);
        line.append(wrap);
      }
    });
    container.append(line);
  });
}

/* Evo UI toggle */
const evoToggle=document.getElementById("evoToggleBtn");
let lastSelectedId=null;
evoToggle.onclick = async ()=>{
  if (!lastSelectedId) return; // nothing selected
  const card = document.getElementById("evoCard");
  if (card.hidden) {
    await loadEvolutionForId(lastSelectedId);
    card.hidden = false;
    evoToggle.textContent = "Hide Evolution Info";
  } else {
    card.hidden = true;
    evoToggle.textContent = "Show Evolution Info";
  }
};

async function loadEvolutionForId(id){
  const card = document.getElementById("evoCard");
  if (!card) return;

  // ensure evoCard skeleton exists
  if (!document.getElementById("evoTitle") || !document.getElementById("evoContent")) {
    card.innerHTML = `
      <div id="evoTitle" style="font-weight:700;margin-bottom:6px;">Evolution</div>
      <div id="evoContent"></div>
    `;
  }

  const titleEl = document.getElementById("evoTitle");
  const contentEl = document.getElementById("evoContent");

  try {
    contentEl.innerHTML = `<em>Loading‚Ä¶</em>`;

    const speciesRes = await fetch(`https://pokeapi.co/api/v2/pokemon-species/${id}/`);
    const species = await speciesRes.json();
    const evoRes = await fetch(species.evolution_chain.url);
    const evo = await evoRes.json();

    // Build paths with full evolution_details
    const paths = [];
    function dfs(node, path){
      const sid = extractIdFromUrl(node.species.url);
      const current = [
        ...path,
        { id: sid, name: title(node.species.name), details: node.evolution_details || [] }
      ];
      if(!node.evolves_to || node.evolves_to.length === 0) paths.push(current);
      else node.evolves_to.forEach(next => dfs(next, current));
    }
    dfs(evo.chain, []);

    // Render chain(s)
    titleEl.textContent = `Evolution ‚Äî ${title(species.name)}`;
    contentEl.innerHTML = "";
    paths.forEach(path => {
      const line = document.createElement("div");
      line.className = "evo-line";
      path.forEach((node, idx) => {
        const nodeDiv = document.createElement("div");
        nodeDiv.className = "evo-node";
        nodeDiv.innerHTML = `
          <img src="${evoImgUrl(node.id)}" alt="${node.name}">
          <div class="evo-name">${title(node.name)}</div>
        `;
        nodeDiv.onclick = () => selectPokeById(node.id);
        line.append(nodeDiv);

        // Between nodes ‚Üí show method
        if (idx < path.length - 1) {
          const next = path[idx + 1];
          const methodText = formatMethod(next.details);
          const wrap = document.createElement("div");
          wrap.style.display = "flex";
          wrap.style.flexDirection = "column";
          wrap.style.alignItems = "center";
          wrap.innerHTML = `
            <div class="evo-arrow">‚Üí</div>
            <div class="evo-method">${methodText || ""}</div>
          `;
          line.append(wrap);
        }
      });
      contentEl.append(line);
    });

  } catch (e) {
    console.warn(e);
    contentEl.innerHTML = "<em>Could not load evolution data.</em>";
  }
}

/* Select Pok√©mon */
async function selectPoke(p) {
  if (!p || typeof p !== "object") {
    console.warn("Invalid Pok√©mon object:", p);
    return;
  }

  // üîí Always guarantee we have types
  if (!Array.isArray(p.types) || !p.types.length) {
    try {
      const r = await fetch(`https://pokeapi.co/api/v2/pokemon/${p.id}/`);
      const j = await r.json();
      p.types = j?.types?.map(t => title(t.type.name)) || [];
    } catch (e) {
      console.warn("Failed to load types for", p.id, e);
      p.types = [];
    }
  }

  lastSelectedId = p.id;
    evoToggle.disabled = false;
    evoToggle.classList.remove("disabled");
  document.getElementById("evoCard").hidden = true;
  evoToggle.textContent = "Show Evolution Info";
  pokeList.innerHTML = "";
  pokeInput.value = p.name || "";
  const types = Array.isArray(p.types) ? p.types : [];

  // üñºÔ∏è Artwork (regular + shiny)
  const img = document.getElementById("pokeImg");
  img.classList.remove("pulse");
  img.classList.add("active");
  img.src = `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/other/official-artwork/${p.id}.png`;

  // üü© Safe type badges
  const box = document.getElementById("pokeTypes");
  box.innerHTML = "";
  types.forEach(t => {
    const b = document.createElement("span");
    b.className = "type-badge";
    b.textContent = t;
    b.style.background = typeColors[t] || typeColors[title(t)] || "#888";
    box.append(b);
  });

  // Defense/offense
  const def = calcDefense(types);
  renderDefenseOnly(document.getElementById("pokeResults"), p.name || `#${p.id}`, def);
  t1.value = types[0] || "";
  t2.value = types[1] || "";
  updateTypePreview();
  const label = types.length ? types.join(" / ") : "Unknown";
  const off = calcOffense(types);
  renderBoth(document.getElementById("typeResults"), label, def, off);

  if (typeof showMoves === "function") showMoves(p.name || `#${p.id}`, p.id);
}

async function selectPokeById(id){
  await loadData();
  const found=pokedata.find(x=>x.id===id);
  if(found){ selectPoke(found); return; }
  const res=await fetch(`https://pokeapi.co/api/v2/pokemon/${id}/`);
  const j=await res.json();
  const types=j.types.map(t=>title(t.type.name));
  const name=title(j.name);
  selectPoke({id,name,types});
}

/* Pok√©mon reset ‚Äî full clear including new UI elements */
document.getElementById("pokeResetBtn").onclick = () => {
  console.log("Full Pok√©mon reset triggered.");

  // Clear search & panels
  pokeInput.value = "";
  document.getElementById("pokeList").innerHTML = "";
  document.getElementById("pokeResults").innerHTML = "";
  document.getElementById("pokeTypes").innerHTML = "";
  document.getElementById("typeResults").innerHTML = "";

  // Clear selection state so evo toggle cannot use stale id
  lastSelectedId = null;

  // Remove side-by-side art wrapper (regular + shiny)
  const wrap = document.getElementById("pokeArtWrap");
  if (wrap) wrap.remove();

  // Restore placeholder image in correct container
  let holder = document.getElementById("pokeControls") || document.getElementById("pokeSection") || document.body;
  let img = document.getElementById("pokeImg");
  if (!img) {
    img = document.createElement("img");
    img.id = "pokeImg";
    img.style.width = "140px";
    holder.insertBefore(img, holder.firstChild);
  }
  // your helper that sets icon + pulse class
  if (typeof hidePokemonImage === "function") hidePokemonImage(); 
  else { img.src = "icon-192.png"; img.classList.add("pulse"); img.classList.remove("active"); }

  // Remove shiny outright
  const shiny = document.getElementById("pokeImgShiny");
  if (shiny) shiny.remove();

  // Clear moves
  const tbody = document.querySelector("#movesTable tbody");
  if (tbody) tbody.innerHTML = `<tr><td colspan="5">No data yet.</td></tr>`;

  // Hide evo card and clear its content (keep skeleton shell)
  const evoCard = document.getElementById("evoCard");
  if (evoCard) {
    const content = document.getElementById("evoContent");
    if (content) content.innerHTML = "";
    const titleEl = document.getElementById("evoTitle");
    if (titleEl) titleEl.textContent = "Evolution";
    evoCard.hidden = true;
  }
  evoToggle.textContent = "Show Evolution Info";
  evoToggle.disabled = true;
  evoToggle.classList.add("disabled");

  // Reset type selects
  t1.value = ""; 
  t2.value = "";

  window.scrollTo(0, 0);
  console.log("Pok√©mon data fully cleared.");
};

/* --- Type checker button (final safe version) --- */
document.getElementById("checkBtn").onclick = () => {
  const t1El = document.getElementById("type1");
  const t2El = document.getElementById("type2");

  // make sure dropdowns exist
  if (!t1El || !t2El) {
    alert("Type dropdowns not ready yet. Try switching back to the Home tab and then re-open the Type Checker.");
    return;
  }

  const t1Val = t1El.value || "";
  const t2Val = t2El.value || "";

  const sel = [];
  if (t1Val) sel.push(t1Val);
  if (t2Val) sel.push(t2Val);

  if (sel.length === 0) {
    alert("Please select at least one type before checking.");
    return;
  }

  const label = sel.join(" / ");
  const def = calcDefense(sel);
  const off = calcOffense(sel);

  const target = document.getElementById("typeResults");
  if (target) renderBoth(target, label, def, off);
};

/* PWA registration only over http(s) */
if("serviceWorker" in navigator && location.protocol.startsWith("http")){
  navigator.serviceWorker.register("sw.js");
}

/* === NEW FEATURES JS (append at end) === */
/* This code assumes your existing variables/functions:
   - types, typeColors, typeChart
   - calcDefense(selTypes), calcOffense(selTypes)
   - loadData(), pokedata, selectPoke(p), selectPokeById(id)
   - title(s) helper (if you have it; fallback inline if not)
*/

/* ---------- Helper: title-case fallback if missing ---------- */
if (typeof title !== "function") {
  var title = (s) => s.replace(/-/g," ").replace(/\b\w/g, c => c.toUpperCase());
}

/* ---------- Helper: images ---------- */
function artUrl(id){
  return `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/other/official-artwork/${id}.png`;
}

/* ---------- Helper: multiplier from one attacking type vs defender types ---------- */
function multAtkVsDefType(atk, defTypes){
  let mult = 1;
  defTypes.forEach(def=>{
    if (typeChart[def].weak.includes(atk))   mult *= 2;
    if (typeChart[def].resist.includes(atk)) mult *= 0.5;
    if (typeChart[def].immune.includes(atk)) mult *= 0;
  });
  return mult;
}

/* ---------- Best attack from a set of attacker types vs defender types ---------- */
function bestAttack(attackerTypes, defenderTypes){
  let best = {mult: 1, types: []};
  attackerTypes.forEach(atk=>{
    const m = multAtkVsDefType(atk, defenderTypes);
    if (m > best.mult) { best = {mult: m, types: [atk]}; }
    else if (m === best.mult) { best.types.push(atk); }
  });
  // unique
  best.types = [...new Set(best.types)];
  return best;
}

// === GLOBAL TEAM STORAGE ===
const TEAM_KEY = "poketype-team-v1";
let team = [];

function saveTeam() {
  localStorage.setItem(TEAM_KEY, JSON.stringify(team));
}
function loadTeam() {
  try {
    const raw = localStorage.getItem(TEAM_KEY);
    const parsed = JSON.parse(raw);
    team = Array.isArray(parsed) ? parsed : [];
  } catch (e) {
    team = [];
  }
}

/* ---------- Tabs: make a new Home tab + three feature tabs/sections ---------- */
(function injectFeatureTabs(){
  const tabsWrap = document.getElementById("modeTabs");
  const main = document.querySelector("main");
  if (!tabsWrap || !main) return;

  // Avoid duplicate injection
  if (document.getElementById("homeSection")) return;

  // Build tabs
  const mkTab = (txt, targetId) => {
    const div = document.createElement("div");
    div.className = "tab";
    div.dataset.target = targetId;
    div.textContent = txt;
    return div;
  };

  const homeTab   = mkTab("Home",      "homeSection");
  const comboTab  = mkTab("Type Combo","comboSection");
  const vsTab     = mkTab("Matchup VS","vsSection");
  const teamTab   = mkTab("Team",      "teamSection");

  // Insert Home at the front
  tabsWrap.prepend(homeTab);
  tabsWrap.append(comboTab, vsTab, teamTab);

  // Sections
  const home = document.createElement("section");
  home.id = "homeSection";
  home.className = "section";
  home.innerHTML = `
    <div class="resultCard">
      <div class="home-grid">
        <div class="home-card" data-go="typeSection">
          <div class="title">Type Checker</div>
          <div class="desc">Pick a type or pair to explore counters and coverage.</div>
        </div>
        <div class="home-card" data-go="pokeSection">
          <div class="title">Pok√©mon Checker</div>
          <div class="desc">Look up a Pok√©mon‚Äôs weaknesses and evolution line.</div>
        </div>
        <div class="home-card" data-go="comboSection">
          <div class="title">Type Combo Search</div>
          <div class="desc">Find Pok√©mon with a single or dual typing.</div>
        </div>
        <div class="home-card" data-go="vsSection">
          <div class="title">Matchup (VS)</div>
          <div class="desc">Compare two Pok√©mon for type advantage.</div>
        </div>
        <div class="home-card" data-go="teamSection">
          <div class="title">Team Coverage</div>
          <div class="desc">Build a team and see weaknesses & coverage.</div>
        </div>
      </div>
    </div>
  `;

  const combo = document.createElement("section");
  combo.id = "comboSection";
  combo.className = "section";
  combo.innerHTML = `
    <div class="resultCard tool-wrap">
      <div class="tool-row">
        <select id="comboType1" class="tool-wide"></select>
        <select id="comboType2" class="tool-wide">
          <option value="">(none)</option>
        </select>
      </div>
      <div class="tool-row">
        <button id="comboSearchBtn">Search</button>
        <button id="comboClearBtn">Clear</button>
      </div>
      <div id="comboResults" class="poke-grid"></div>
    </div>
  `;

  const vs = document.createElement("section");
  vs.id = "vsSection";
  vs.className = "section";
  vs.innerHTML = `
    <div class="resultCard">
      <div class="vs-wrap">
        <div class="vs-col">
          <div class="vs-title">Pok√©mon A</div>
          <input id="vsAInput" placeholder="Search Pok√©mon A..." class="tool-wide" autocomplete="off">
          <div id="vsAList"></div>
          <div id="vsASummary"></div>
        </div>
        <div class="vs-col">
          <div class="vs-title">Pok√©mon B</div>
          <input id="vsBInput" placeholder="Search Pok√©mon B..." class="tool-wide" autocomplete="off">
          <div id="vsBList"></div>
          <div id="vsBSummary"></div>
        </div>
      </div>
    </div>
  `;

  const teamSection = document.createElement("section");
  teamSection.id = "teamSection";
  teamSection.className = "section";
  teamSection.innerHTML = `
    <div class="resultCard team-wrap">
      <input id="teamInput" placeholder="Add Pok√©mon to team..." class="tool-wide" autocomplete="off">
      <div id="teamSuggest"></div>
      <div id="teamSlots" class="team-bar"></div>
      <div class="team-actions">
        <button id="saveTeamBtn">Save Team</button>
        <button id="clearTeamBtn">Clear Team</button>
      </div>
      <div class="resultCard" id="teamDefense"></div>
      <div class="resultCard" id="teamOffense"></div>
    </div>
  `;

  // Put Home first
  const firstOld = document.getElementById("typeSection");
  main.prepend(home);
  main.append(combo, vs, teamSection);

  // Home navigation
  home.querySelectorAll(".home-card").forEach(card=>{
    card.onclick = () => {
      const target = card.getAttribute("data-go");
      switchTab(target);
    };
  });

  // Extend tab behavior to include the new tabs
  [homeTab, comboTab, vsTab, teamTab].forEach(tab=>{
    tab.onclick = () => switchTab(tab.dataset.target);
  });

  // Helper to switch tabs/sections
  function switchTab(targetId){
    document.querySelectorAll(".tab").forEach(t=>t.classList.remove("active"));
    document.querySelectorAll(".section").forEach(s=>s.classList.remove("active"));
    const tab = [...document.querySelectorAll(".tab")].find(t=>t.dataset.target===targetId);
    if (tab) tab.classList.add("active");
    const sec = document.getElementById(targetId);
    if (sec) sec.classList.add("active");
  }

  // Fill combo selects with type options
  function fillTypeOptions(sel){
    types.forEach(t=>{
      const opt = new Option(t,t);
      opt.style.background = typeColors[t];
      opt.style.color = "#fff";
      opt.style.fontWeight = "600";
      sel.add(opt);
    });
  }
  fillTypeOptions(combo.querySelector("#comboType1"));
  fillTypeOptions(combo.querySelector("#comboType2"));

  /* ---------- TYPE COMBO SEARCH ---------- */
  const comboType1 = document.getElementById("comboType1");
  const comboType2 = document.getElementById("comboType2");
  const comboResults = document.getElementById("comboResults");
  document.getElementById("comboSearchBtn").onclick = async () => {
    const a = document.getElementById("comboType1").value;
    const b = document.getElementById("comboType2").value; // may be ""

    const comboResults = document.getElementById("comboResults");
    comboResults.innerHTML = "";

    if (!a && !b) return;

    // helper: fetch a Set of pokemon ids that have a given type
    async function fetchTypeSet(typeName){
        const r = await fetch(`https://pokeapi.co/api/v2/type/${typeName.toLowerCase()}`);
        if (!r.ok) { console.warn("Type fetch failed", typeName); return new Set(); }
        const j = await r.json();
        const ids = j.pokemon
        .map(x => extractIdFromUrl(x.pokemon.url))
        .filter(Boolean);
        return new Set(ids);
    }

    // single-type or dual-type logic via set intersection
    let idList = [];
    if (a && !b) {
        const setA = await fetchTypeSet(a);
        idList = Array.from(setA);
    } else if (!a && b) {
        const setB = await fetchTypeSet(b);
        idList = Array.from(setB);
    } else {
        const [setA, setB] = await Promise.all([fetchTypeSet(a), fetchTypeSet(b)]);
        // intersect
        idList = Array.from(setA).filter(id => setB.has(id));
    }

    // render cards (limit so mobile stays snappy)
    const limited = idList.slice(0, 200);
    if (!limited.length) {
        comboResults.innerHTML = `<div class="resultCard" style="text-align:center">No matches for ${[a,b].filter(Boolean).join(" / ")}.</div>`;
        return;
    }

    limited.forEach(id => {
        const card = document.createElement("div");
        card.className = "poke-card";
        const name = cap((id && id.toString()) || "pokemon");

        card.innerHTML = `
            <img src="https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/other/official-artwork/${id}.png" loading="lazy">
            <div class="nm">#${String(id).padStart(3,'0')}</div>
        `;

        // when clicked, jump to Pok√©mon checker and load full details
        card.onclick = () => {
            window.switchTab("pokeSection");

            // Always prefer selectPokeById to guarantee types, moves, and shiny data
            if (typeof selectPokeById === "function") {
            selectPokeById(id);
            } else if (typeof selectPoke === "function") {
            // fallback: minimal safe object
            selectPoke({ id, name: `#${id}`, types: [] });
            } else {
            console.warn("No valid selection function found for ID:", id);
            }
        };

        comboResults.append(card);
        });
    };

  document.getElementById("comboClearBtn").onclick = ()=>{ comboType1.selectedIndex = 0; comboType2.selectedIndex = 0; comboResults.innerHTML = ""; };

  /* ---------- MATCHUP (VS) ---------- */
  const vsAInput = document.getElementById("vsAInput");
  const vsBInput = document.getElementById("vsBInput");
  const vsAList = document.getElementById("vsAList");
  const vsBList = document.getElementById("vsBList");
  const vsASummary = document.getElementById("vsASummary");
  const vsBSummary = document.getElementById("vsBSummary");
  let vsA=null, vsB=null;

  async function suggestInto(input, list, setter){
    await loadData();
    const q = input.value.toLowerCase();
    list.innerHTML = "";
    if (!q) return;
    pokedata.filter(p=>p.name.toLowerCase().includes(q)).slice(0,12).forEach(p=>{
      const div = document.createElement("div");
      div.textContent = p.name;
      div.style.cursor = "pointer";
      div.onclick = ()=>{ setter(p); list.innerHTML=""; input.value=p.name; };
      list.append(div);
    });
  }
  vsAInput.addEventListener("input",()=>suggestInto(vsAInput, vsAList, p=>{vsA=p; renderVS();}));
  vsBInput.addEventListener("input",()=>suggestInto(vsBInput, vsBList, p=>{vsB=p; renderVS();}));

  function renderVS(){
    vsASummary.innerHTML = "";
    vsBSummary.innerHTML = "";
    if (!vsA || !vsB) return;

    const aBest = bestAttack(vsA.types, vsB.types); // A's best move vs B
    const bBest = bestAttack(vsB.types, vsA.types); // B's best move vs A

    const mk = (who, self, opp, best) => {
      const box = who==="A" ? vsASummary : vsBSummary;
      const head = document.createElement("div");
      head.className = "vs-title";
      head.textContent = `${self.name} ‚Üí ${opp.name}`;
      const row = document.createElement("div");
      row.className = "coverage-row";
      best.types.forEach(t=>{
        const span = document.createElement("span");
        span.className = "vs-chip";
        span.style.background = typeColors[t];
        span.textContent = `${t} √ó${best.mult}`;
        row.append(span);
      });
      box.append(head, row);
    };
    mk("A", vsA, vsB, aBest);
    mk("B", vsB, vsA, bBest);
  }

  /* ---------- TEAM COVERAGE (types for defense, moves for offense) ---------- */
(function(){
  const teamInput   = document.getElementById("teamInput");
  const teamSuggest = document.getElementById("teamSuggest");
  const teamSlots   = document.getElementById("teamSlots");
  const teamDefense = document.getElementById("teamDefense");
  const teamOffense = document.getElementById("teamOffense");

  // Keep your existing storage key & structure, but allow a 'moves' array per mon
  const TEAM_KEY = "poketype-team-v1";
  let team = [];

  function saveTeam(){ localStorage.setItem(TEAM_KEY, JSON.stringify(team)); }
  function loadTeam(){
    try {
      const raw = localStorage.getItem(TEAM_KEY);
      const parsed = JSON.parse(raw);
      team = Array.isArray(parsed) ? parsed.map(p => ({...p, moves: p.moves || []})) : [];
    } catch { team = []; }
  }

  // -------- Suggest list (base forms only) --------
  async function teamSuggestHandler(){
    await loadData();
    const q = (teamInput.value || "").toLowerCase();
    teamSuggest.innerHTML = "";
    if (!q) return;

    const filtered = pokedata.filter(p =>
      p.name.toLowerCase().includes(q) &&
      !p.name.includes("-") &&
      p.id <= 1025 &&
      !p.name.match(/mega|gmax|totem|starter|battle|cosplay|cap|partner|rock-star|belle|pop-star|phd|libre|original|world|hisui|paldea|alola|galar/i)
    );

    filtered.slice(0,12).forEach(p=>{
      const d = document.createElement("div");
      d.textContent = p.name;
      d.style.cursor = "pointer";
      d.onclick = async ()=>{
        await addToTeam(p);
        teamSuggest.innerHTML = "";
        teamInput.value = "";
      };
      teamSuggest.append(d);
    });
  }
  if (teamInput) teamInput.addEventListener("input", teamSuggestHandler);

  // Guarantee we have types for coverage
  async function ensureTypes(id){
    try{
      const r = await fetch(`https://pokeapi.co/api/v2/pokemon/${id}/`);
      const j = await r.json();
      return (j.types || []).map(t=>title(t.type.name));
    }catch{ return []; }
  }

  async function addToTeam(p){
    if (team.length >= 6) return;
    if (team.some(x => x.id === p.id)) return;
    const types = Array.isArray(p.types) && p.types.length ? p.types : await ensureTypes(p.id);
    team.push({ id: p.id, name: p.name, types, moves: [] });
    saveTeam();
    await renderTeam();
  }
  function removeFromTeam(id){
    team = team.filter(x => x.id !== id);
    saveTeam();
    renderTeam();
  }

  // -------- Moveset editor (modal) --------
  let allMoves = [];                 // [{name, url}]
  let activeIndex = null;            // index in team[]
  let tempMoves = [];                // working copy for Cancel/Save
  const moveTypeCache = JSON.parse(localStorage.getItem("moveTypeCacheV1") || "{}");

  async function loadAllMoves(){
    if (allMoves.length) return;

    const res = await fetch("https://pokeapi.co/api/v2/move?limit=10000");
    if (!res.ok) return;
    const data = await res.json();

    // Exclude Z-Moves and Max/G-Max moves by API slug
    const banRE = new RegExp(
      [
        // Max / G-Max
        '^max-', '^g-max-',
        // 18 type-based Z-moves
        '^breakneck-blitz$', '^all-out-pummeling$', '^supersonic-skystrike$',
        '^acid-downpour$', '^continental-crush$', '^savage-spin-out$',
        '^never-ending-nightmare$', '^corkscrew-crash$', '^inferno-overdrive$',
        '^hydro-vortex$', '^bloom-doom$', '^gigavolt-havoc$',
        '^shattered-psyche$', '^subzero-slammer$', '^devastating-drake$',
        '^black-hole-eclipse$', '^twinkle-tackle$', '^tectonic-rage$',
        // Signature Z-moves (non-type generics)
        '^10-000-000-volt-thunderbolt$', '^catastropika$', '^stoked-sparksurfer$',
        '^pulverizing-pancake$', '^extreme-evoboost$', '^sinister-arrow-raid$',
        '^malicious-moonsault$', '^oceanic-operetta$', '^guardian-of-alola$',
        '^soul-stealing-7-star-strike$', '^light-that-burns-the-sky$',
        '^menacing-moonraze-maelstrom$', '^searing-sunraze-smash$',
        "^let-s-snuggle-forever$"
      ].join('|'),
      'i'
    );

    allMoves = data.results
      .map(m => ({ name: title(m.name), url: m.url, slug: m.name }))
      .filter(m => !banRE.test(m.slug));
  }


  async function getMoveType(moveName){
    const key = moveName.toLowerCase();
    if (moveTypeCache[key]) return moveTypeCache[key];
    const rec = allMoves.find(m => m.name.toLowerCase() === key);
    if (!rec) return null;
    const r = await fetch(rec.url);
    if (!r.ok) return null;
    const j = await r.json();
    const t = title(j.type.name);
    moveTypeCache[key] = t;
    localStorage.setItem("moveTypeCacheV1", JSON.stringify(moveTypeCache));
    return t;
  }

  async function renderSelectedMoves(){
    const box = document.getElementById("selectedMoves");
    if (!box) return;
    box.innerHTML = "";
    for (const [i, mv] of tempMoves.entries()){
      const t = await getMoveType(mv);
      const chip = document.createElement("span");
      chip.textContent = mv;
      chip.className = "move-chip";
      chip.style.background = t && typeColors[t] ? typeColors[t] : "var(--accent)";
      chip.style.color = "#000";
      chip.title = "Click to remove";
      chip.onclick = () => {
        tempMoves.splice(i, 1);
        renderSelectedMoves();
      };
      box.append(chip);
    }
  }

  async function searchMoves(q){
    await loadAllMoves();
    const results = document.getElementById("moveSearchResults");
    if (!results) return;
    results.innerHTML = "";
    const s = (q || "").trim().toLowerCase();
    if (!s) return;
    const list = allMoves.filter(m => m.name.toLowerCase().includes(s)).slice(0, 20);
    for (const m of list){
      const row = document.createElement("div");
      row.textContent = m.name;
      row.style.cssText = "padding:6px 8px; cursor:pointer;";
      row.onmouseenter = () => row.style.background = "rgba(255,255,255,.08)";
      row.onmouseleave = () => row.style.background = "transparent";
      row.onclick = async () => {
        if (tempMoves.length >= 4) return;
        if (tempMoves.includes(m.name)) return;
        tempMoves.push(m.name);

        // clear input/results immediately after selecting a move
        const input = document.getElementById("moveSearchInput");
        if (input){ input.value = ""; }
        results.innerHTML = "";

        await renderSelectedMoves();
      };
      results.append(row);
    }
  }

  function openMovesetModal(index){
    activeIndex = index;
    tempMoves = [...(team[activeIndex].moves || [])]; // working copy for cancel
    const modal = document.getElementById("movesetModal");
    if (!modal) return;
    modal.style.display = "flex";

    // (Re)bind listeners now that modal is present
    const input = document.getElementById("moveSearchInput");
    const save  = document.getElementById("saveMovesetBtn");
    const close = document.getElementById("closeMovesetModal");

    if (input) {
      const clone = input.cloneNode(true);
      input.parentNode.replaceChild(clone, input);
      clone.addEventListener("input", e => searchMoves(e.target.value));
      clone.value = "";
    }
    if (close) {
      const clone = close.cloneNode(true);
      close.parentNode.replaceChild(clone, close);
      clone.onclick = () => {
        // discard changes
        tempMoves = [];
        closeMovesetModal();
      };
    }
    if (save) {
      const clone = save.cloneNode(true);
      save.parentNode.replaceChild(clone, save);
      clone.onclick = async () => {
        // commit changes
        team[activeIndex].moves = [...tempMoves];
        saveTeam();
        tempMoves = [];
        closeMovesetModal();
        await renderTeam(); // refresh preview + coverage
      };
    }

    // reset results and draw chips for working copy
    const results = document.getElementById("moveSearchResults");
    if (results) results.innerHTML = "";
    renderSelectedMoves();
  }

  function closeMovesetModal(){
    const modal = document.getElementById("movesetModal");
    if (modal) modal.style.display = "none";
    activeIndex = null;
  }


  // -------- Coverage (Defense: by types, Offense: by move types) --------
  async function updateCoverage(){
    // === Defensive coverage (unchanged) ===
    const atkTypes = Object.keys(typeChart);
    const counts = atkTypes.map(atk=>{
      let weak=0,res=0,imm=0;
      team.forEach(mon=>{
        const m = multAtkVsDefType(atk, mon.types || []);
        if (m>1) weak++;
        else if (m===0) imm++;
        else if (m<1) res++;
      });
      return {atk, weak, res, imm};
    }).sort((a,b)=>b.weak - a.weak);

    teamDefense.innerHTML = `<div class="coverage-title">Team Defense: Top Threats</div>`;
    const defRow = document.createElement("div");
    defRow.className = "coverage-row";
    counts.slice(0,8).forEach(c=>{
      const badge = document.createElement("span");
      badge.className = "coverage-badge";
      badge.style.background = typeColors[c.atk];
      badge.textContent = `${c.atk}: ${c.weak} weak / ${c.res} resist / ${c.imm} immune`;
      defRow.append(badge);
    });
    teamDefense.append(defRow);

    // === Offensive coverage (by selected moves only) ===
    const usedAtkTypes = new Set();
    for (const mon of team){
      if (!mon.moves || !mon.moves.length) continue;
      for (const mv of mon.moves){
        const t = await getMoveType(mv);
        if (t) usedAtkTypes.add(t); // e.g. "Fire"
      }
    }

    const defTypes = Object.keys(typeChart);
    const covered = new Set();
    defTypes.forEach(def => {
      for (const atk of usedAtkTypes){
        // reuse your existing calcOffense() on a single attacking type
        const strong = calcOffense([atk]).strong;
        if (strong.some(x => x.type === def)) { covered.add(def); break; }
      }
    });
    const uncovered = defTypes.filter(d => !covered.has(d));

    teamOffense.innerHTML = `<div class="coverage-title">Team Offense (by Moves)</div>`;
    const row1 = document.createElement("div");
    row1.className = "coverage-row";
    covered.forEach(d=>{
      const b=document.createElement("span");
      b.className="coverage-badge";
      b.style.background=typeColors[d];
      b.textContent=d;
      row1.append(b);
    });
    const row2 = document.createElement("div");
    row2.className="coverage-row";
    uncovered.forEach(d=>{
      const b=document.createElement("span");
      b.className="coverage-badge";
      b.style.background="#444";
      b.textContent=d;
      row2.append(b);
    });
    teamOffense.append(row1,row2);
  }

  // --- slide-to-delete helper (per slot) ---
  function setupSwipeToDelete(slotEl, contentEl, deleteBtn, onRemove) {
    const RAIL = 96;                 // width of delete rail
    const OPEN_SNAP = 70;            // release past this ‚Üí snap open to -RAIL
    const DELETE_TRIP = 140;         // swipe past this ‚Üí delete immediately
    let startX = null, currentX = 0, dragging = false;

    const setX = (x) => { contentEl.style.transform = `translateX(${x}px)`; };

    const endDrag = () => {
      slotEl.classList.remove('dragging');
      dragging = false;

      // decide final state
      if (currentX <= -DELETE_TRIP) {
        // hard swipe ‚Üí delete immediately (no confirm per request)
        setX(-DELETE_TRIP);
        onRemove();
        return;
      }
      if (currentX <= -OPEN_SNAP) {
        setX(-RAIL); // snap open to show Delete
      } else {
        setX(0);     // snap closed
      }
    };

    // Pointer (mouse) support
    contentEl.addEventListener('mousedown', e => {
      startX = e.clientX; dragging = true; slotEl.classList.add('dragging');
    });
    window.addEventListener('mousemove', e => {
      if (!dragging) return;
      const dx = e.clientX - startX;
      currentX = Math.min(0, Math.max(-200, dx)); // clamp [ -200, 0 ]
      setX(currentX);
    });
    window.addEventListener('mouseup', () => {
      if (!dragging) return;
      endDrag();
    });

    // Touch support
    contentEl.addEventListener('touchstart', e => {
      startX = e.touches[0].clientX; dragging = true; slotEl.classList.add('dragging');
    }, { passive: true });
    contentEl.addEventListener('touchmove', e => {
      if (!dragging) return;
      const dx = e.touches[0].clientX - startX;
      currentX = Math.min(0, Math.max(-200, dx));
      setX(currentX);
    }, { passive: true });
    contentEl.addEventListener('touchend', () => {
      if (!dragging) return;
      endDrag();
    }, { passive: true });

    // Tap on delete rail
    if (deleteBtn) deleteBtn.onclick = () => onRemove();
  }

  // -------- Team UI (with slide-to-delete) --------
  async function renderTeam(){
    teamSlots.innerHTML = "";
    for (const [idx,p] of team.entries()){
      const slot = document.createElement("div");
      slot.className = "team-slot";

      // fixed delete rail (sits on the right, outside normal flow)
      const del = document.createElement("button");
      del.className = "slot-delete";
      del.textContent = "Remove";
      del.setAttribute("aria-label", `Remove ${p.name}`);

      // sliding content
      const content = document.createElement("div");
      content.className = "slot-content";
      content.style.transform = "translateX(0)"; // ensure the rail is hidden initially
      content.innerHTML = `
        <div class="slot-left">
          <img class="slot-art" src="${artUrl(p.id)}" loading="lazy" alt="${p.name}">
          <div class="slot-name-line"><div class="slot-name">${p.name}</div></div>
        </div>
        <div class="slot-right">
          <div class="moves-preview" ${Array.isArray(p.moves) && p.moves.length ? "" : 'data-empty="1"'}></div>
          <div class="slot-actions">
            ${Array.isArray(p.moves) && p.moves.length ? "" : '<button class="editMoves">‚ûï Add moves</button>'}
          </div>
        </div>
      `;

      // assemble
      slot.append(content, del);

      // swipe/drag behavior
      setupSwipeToDelete(slot, content, del, () => removeFromTeam(p.id));

      // moveset openers
      const editBtn = content.querySelector(".editMoves");
      if (editBtn) editBtn.onclick = () => openMovesetModal(idx);

      const preview = content.querySelector(".moves-preview");
      preview.onclick = () => openMovesetModal(idx);
      preview.innerHTML = "";

      // render move chips with type color
      if (Array.isArray(p.moves) && p.moves.length){
        for (const mv of p.moves){
          const t = await getMoveType(mv);
          const chip = document.createElement("span");
          chip.textContent = mv;
          chip.className = "move-chip";
          chip.style.background = t && typeColors[t] ? typeColors[t] : "var(--accent)";
          chip.style.color = "#000";
          preview.append(chip);
        }
      } else {
        const hint = document.createElement("span");
        hint.className = "moves-hint";
        hint.textContent = "Tap to add moves";
        preview.append(hint);
      }

      teamSlots.append(slot);
    }
    await updateCoverage();
  }

  // Buttons
  const saveBtn  = document.getElementById("saveTeamBtn");
  const clearBtn = document.getElementById("clearTeamBtn");
  if (saveBtn)  saveBtn.onclick  = ()=> saveTeam();
  if (clearBtn) clearBtn.onclick = ()=>{ team=[]; saveTeam(); renderTeam(); };

  // Init
  loadTeam();
  renderTeam();
})();
  // make switchTab callable from other handlers that use window.switchTab(...)
  window.switchTab = switchTab;
})(); // <-- closes (function injectFeatureTabs(){ ... })

/* === HOME-ONLY NAVIGATION (fixed timing) === */
(function setupHomeNavigation(){
  // Hide tab bar
  const tabs = document.getElementById("modeTabs");
  if (tabs) tabs.style.display = "none";

  // Global switch function
  window.switchTab = function(targetId){
    document.querySelectorAll(".section").forEach(s => s.classList.remove("active"));
    const sec = document.getElementById(targetId);
    if (sec) sec.classList.add("active");
  };

  // Helper to ensure a Home button exists at the top of each section
  function ensureHomeButtons(){
    ["typeSection","pokeSection","comboSection","vsSection","teamSection"].forEach(id=>{
      const sec = document.getElementById(id);
      if (sec && !sec.querySelector(".home-btn")) {
        const btn = document.createElement("button");
        btn.className = "home-btn";
        btn.textContent = "‚Üê Home";
        btn.onclick = () => window.switchTab("homeSection");
        sec.prepend(btn);
      }
    });
  }

  // Run once immediately (covers sections that already exist)
  ensureHomeButtons();

  // Also run whenever sections are injected/changed
  const observer = new MutationObserver(ensureHomeButtons);
  observer.observe(document.querySelector("main"), {childList:true, subtree:true});

  // Go to Home on startup
  window.switchTab("homeSection");
})();

/* === MOVES PANEL + SHINY + GENERATION SELECTOR === */

// Version-group ‚Üí generation map
const versionGroupToGen = {
  "red-blue":1,"yellow":1,
  "gold-silver":2,"crystal":2,
  "ruby-sapphire":3,"emerald":3,"firered-leafgreen":3,
  "diamond-pearl":4,"platinum":4,"heartgold-soulsilver":4,
  "black-white":5,"black-2-white-2":5,
  "x-y":6,"omega-ruby-alpha-sapphire":6,
  "sun-moon":7,"ultra-sun-ultra-moon":7,
  "sword-shield":8,"brilliant-diamond-and-shining-pearl":8,
  "scarlet-violet":9
};

// Inject panel
(function setupMovesPanel(){
  const sec=document.getElementById("pokeSection");
  if(!sec) return;
  const div=document.createElement("div");
  div.className="moves-panel";
  div.innerHTML=`
    <div class="moves-header">
        <h3 style="margin:0;">Level-Up Moves</h3>
        <select id="genSelect">
        ${Array.from({length:9},(_,i)=>`<option value="${i+1}">Gen ${i+1}</option>`).join("")}
        </select>
    </div>
    <table class="moves-table" id="movesTable">
        <thead><tr><th>Lvl</th><th>Move</th><th>Type</th><th>Power</th><th>Category</th></tr></thead>
        <tbody><tr><td colspan="5">No data yet.</td></tr></tbody>
    </table>`;
    const genSelect = div.querySelector("#genSelect");
    genSelect.value = "9"; // ‚úÖ default to Gen 9
    sec.appendChild(div);
})();

// Render shiny + fetch moves
async function showMoves(pName,pId){
  const genSelect=document.getElementById("genSelect");
  const tbody=document.querySelector("#movesTable tbody");
  if(!genSelect||!tbody) return;

  // Ensure both regular and shiny sit side-by-side
const img = document.getElementById("pokeImg");

// Build a wrapper once and move the existing image into it
let wrap = document.getElementById("pokeArtWrap");
if (!wrap) {
  wrap = document.createElement("div");
  wrap.id = "pokeArtWrap";
  img.parentNode.insertBefore(wrap, img);
  wrap.appendChild(img); // move existing regular art into the wrapper
}

// Create (or reuse) the shiny image inside the same wrapper
let shiny = document.getElementById("pokeImgShiny");
if (!shiny) {
  shiny = document.createElement("img");
  shiny.id = "pokeImgShiny";
  shiny.style.width = "140px";
  shiny.style.opacity = "1";
  shiny.style.transition = "opacity .3s ease";
  wrap.appendChild(shiny);
}

// Set shiny artwork URL
shiny.src = `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/other/official-artwork/shiny/${pId}.png`;
shiny.hidden = false;


  const res=await fetch(`https://pokeapi.co/api/v2/pokemon/${pId}`);
  const data=await res.json();

  async function render(gen){
    const lvlMoves=data.moves.map(m=>{
      const det=m.version_group_details.find(vgd=>
        versionGroupToGen[vgd.version_group.name]===gen &&
        vgd.move_learn_method.name==="level-up"
      );
      if(!det) return null;
      return {name:m.move.name,url:m.move.url,level:det.level_learned_at};
    }).filter(Boolean).sort((a,b)=>a.level-b.level);

    if(!lvlMoves.length){
      tbody.innerHTML=`<tr><td colspan="5">No level-up moves for Gen ${gen}.</td></tr>`;
      return;
    }

    const detailed=await Promise.all(lvlMoves.map(async m=>{
      try{
        const r=await fetch(m.url);const j=await r.json();
        return {
          name:m.name.replace(/-/g," "),
          level:m.level||"‚Äî",
          type:j.type.name,
          power:j.power??"‚Äî",
          cat:j.damage_class.name
        };
      }catch{return {...m,type:"unknown",power:"‚Äî",cat:"status"};}
    }));

    // map damage class to your icon filenames
    const iconFor = (cat) => {
    const c = (cat || "").toLowerCase();
    if (c === "physical") return "icon-physical.png";
    if (c === "special")  return "icon-special.png";
    return "icon-status.png"; // status
    };

    tbody.innerHTML = detailed.map(m=>{
    const color = typeColorsLower[m.type] || "#666";
    const icon  = iconFor(m.cat);
    const catLabel = m.cat ? m.cat.charAt(0).toUpperCase() + m.cat.slice(1) : "";
    return `<tr>
        <td>${m.level}</td>
        <td style="text-transform:capitalize">${m.name}</td>
        <td><span class="move-type-badge" style="background:${color}">${m.type}</span></td>
        <td>${m.power}</td>
        <td>
        <div class="cat-wrapper" data-label="${catLabel}">
            <img src="${icon}" alt="${catLabel}" class="cat-icon">
        </div>
        </td>
    </tr>`;
    }).join("");
  }

  render(parseInt(genSelect.value));
  genSelect.onchange=()=>render(parseInt(genSelect.value));
}

// Hook into selectPoke
const oldSelectPoke=selectPoke;
selectPoke=async function(p){
  await oldSelectPoke(p);
  showMoves(p.name,p.id);
};

// Tooltip behavior fix for mobile
document.addEventListener("click", (e) => {
  const wrap = e.target.closest(".cat-wrapper");
  document.querySelectorAll(".cat-tooltip").forEach(t => t.remove());
  if (wrap && wrap.dataset.label) {
    const tip = document.createElement("div");
    tip.className = "cat-tooltip";
    tip.textContent = wrap.dataset.label;
    wrap.appendChild(tip);
    requestAnimationFrame(() => tip.style.opacity = 1);
    setTimeout(() => {
      tip.style.opacity = 0;
      setTimeout(() => tip.remove(), 200);
    }, 1500);
  }
});

</script>

<!-- === TEAM MOVESET MODAL === -->
<div id="movesetModal" style="
  display:none; position:fixed; inset:0; background:rgba(0,0,0,.7);
  align-items:center; justify-content:center; z-index:10000;">
  <div style="background:var(--card); border:1px solid var(--accent); border-radius:12px;
              width:92%; max-width:460px; padding:14px; color:var(--text);">
    <h3 style="margin:0 0 8px;">Edit Moveset</h3>
    <input id="moveSearchInput" placeholder="Search moves..." autocomplete="off"
           style="width:100%; padding:8px; border-radius:8px; border:1px solid var(--accent);
                  background:var(--bg); color:var(--text);">
    <div id="moveSearchResults" style="margin-top:8px; max-height:160px; overflow:auto; border:1px solid rgba(255,255,255,.1); border-radius:8px;"></div>
    <div style="margin-top:10px; font-weight:700;">Selected (max 4)</div>
    <div id="selectedMoves" style="display:flex; flex-wrap:wrap; gap:6px; margin-top:6px;"></div>
    <div style="display:flex; gap:8px; justify-content:space-between; margin-top:12px;">
      <button id="closeMovesetModal" style="flex:1;">Cancel</button>
      <button id="saveMovesetBtn"  style="flex:1;">Save</button>
    </div>
  </div>
</div>

</body>
</html>
