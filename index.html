<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>PokéType Checker</title>
<link rel="manifest" href="manifest.json" />
<style>
:root {
  --bg:#0a1224;
  --card:#15254b;
  --accent:#ffb400;
  --text:#fff;
}
/* Base */
* { box-sizing: border-box; }
body { margin:0; font-family: system-ui, Arial, sans-serif; background: var(--bg); color: var(--text); }
header { display:flex; justify-content:space-between; align-items:center; padding:10px 16px; background:var(--card); }
h1 { font-size:1.1rem; margin:0; }
#themeToggle { background:none; border:none; cursor:pointer; color:var(--accent); font-size:1.2rem; }

/* Tabs */
#modeTabs { display:flex; justify-content:center; margin:10px 0; }
.tab {
  padding:8px 16px; background:var(--card); color:var(--text);
  border:1px solid var(--accent); border-radius:8px; margin:0 5px; cursor:pointer;
}
.tab.active { background:var(--accent); color:#000; }

/* Sections & Cards */
.section { display:none; padding:10px; }
.section.active { display:block; }
.resultCard {
  background:var(--card); margin:8px 0; padding:10px;
  border:1px solid var(--accent); border-radius:8px; animation:fade .3s;
}
@keyframes fade { from{opacity:0;} to{opacity:1;} }
.type-badge {
  display:inline-block; border-radius:12px; padding:4px 8px; margin:2px;
  color:#fff; font-weight:600; font-size:.9rem;
}

/* Controls */
#typeControls, #pokeControls {
  display:flex; flex-direction:column; align-items:center; gap:10px; margin-bottom:10px;
}
select, input {
  width:90%; max-width:360px; font-size:1rem; padding:12px; border-radius:8px;
  border:1px solid var(--accent); background:var(--card); color:var(--text); text-align:center;
}
select:focus, input:focus { outline:none; box-shadow:0 0 4px var(--accent); }
#typeButtons { display:flex; justify-content:center; gap:10px; flex-wrap:wrap; }
button {
  font-size:1rem; padding:10px 14px; border-radius:8px; border:1px solid var(--accent);
  background:var(--card); color:var(--text); cursor:pointer;
}
button:hover { background:var(--accent); color:#000; }
#resetBtn, #pokeResetBtn { background:none; border:1px solid var(--accent); color:var(--accent); }
#resetBtn:hover, #pokeResetBtn:hover { background:var(--accent); color:#000; }

/* Divider */
.section-divider {
  margin:16px 0; text-align:center; font-weight:bold; color:var(--accent); position:relative;
}
.section-divider::before, .section-divider::after {
  content:""; position:absolute; top:50%; width:40%; height:1px;
  background:linear-gradient(to right,transparent,var(--accent),transparent);
}
.section-divider::before { left:0; } .section-divider::after { right:0; }

/* Previews */
#typePreview, #pokeTypePreview { display:flex; justify-content:center; gap:6px; }
.type-preview-badge { display:inline-block; width:60px; height:18px; border-radius:10px; }

/* Pokémon checker specifics */
#pokeImg { width:140px; display:block; margin:10px auto; }
#pokeList div { padding:6px 10px; background:var(--card); border:1px solid var(--accent);
  border-radius:8px; margin:2px 0; }
#pokeList div:hover { background:var(--accent); color:#000; }

/* Evolution UI */
#pokeButtonsRow { display:flex; justify-content:center; gap:10px; margin-top:10px; flex-wrap:wrap; }
#evoCard { background:var(--card); border:1px solid var(--accent); border-radius:12px; padding:10px; margin:10px 0; }
.evo-line { display:flex; align-items:center; justify-content:center; flex-wrap:wrap; gap:10px; }
.evo-node { text-align:center; cursor:pointer; }
.evo-node img { width:72px; height:72px; object-fit:contain; display:block; margin:0 auto 4px; }
.evo-name { font-size:.85rem; }
.evo-arrow { color:var(--accent); font-weight:700; display:flex; align-items:center; gap:6px; }
.evo-method { font-size:.75rem; opacity:.9; }

/* Responsive layout */
@media (min-width: 700px) {
  main { display:grid; grid-template-columns: 1fr 1fr; gap:12px; padding:10px; }
}

@keyframes pokePulse {
  0%   { filter: drop-shadow(0 0 6px rgba(255,180,0,0.35)); }
  50%  { filter: drop-shadow(0 0 18px rgba(255,180,0,0.75)); }
  100% { filter: drop-shadow(0 0 6px rgba(255,180,0,0.35)); }
}

/* Default: subtle placeholder (smaller, semi-transparent) */
#pokeImg{
  display:block;
  margin:10px auto;
  width:100px;
  opacity:0.55;
  transition: opacity .45s ease, width .25s ease;
}

/* Pulsing amber glow state (when showing Poké Ball icon) */
#pokeImg.pulse{
  animation: pokePulse 2.4s ease-in-out infinite;
}

/* Active Pokémon artwork (larger, fully opaque, no pulse) */
#pokeImg.active{
  width:140px;
  opacity:1;
  animation:none;
  filter:none;
}

/* === NEW FEATURES CSS (append at end) === */

/* Home screen cards */
.home-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 10px;
  margin: 10px 0;
}
.home-card {
  background: var(--card);
  border: 1px solid var(--accent);
  border-radius: 12px;
  padding: 12px;
  text-align: center;
  cursor: pointer;
  transition: transform .15s ease, box-shadow .15s ease, border-color .15s ease;
}
.home-card:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 14px rgba(0,0,0,.25);
  border-color: #ffd36a;
}
.home-card .title { font-weight: 700; margin-bottom: 6px; }
.home-card .desc { font-size: .9rem; opacity: .9; }

/* Shared layouts */
.tool-wrap { display:flex; flex-direction:column; gap:10px; align-items:center; }
.tool-row { display:flex; gap:8px; flex-wrap:wrap; justify-content:center; }
.tool-wide { width: 92%; max-width: 420px; }

/* Result grids */
.poke-grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 8px;
  width: 100%;
}
.poke-card {
  background: var(--card);
  border: 1px solid var(--accent);
  border-radius: 10px;
  padding: 8px;
  text-align: center;
  cursor: pointer;
}
.poke-card img { width: 72px; height: 72px; object-fit: contain; display:block; margin: 0 auto 4px; }
.poke-card .nm { font-size: .85rem; }

/* VS panel */
.vs-wrap { display:flex; gap:10px; flex-wrap:wrap; justify-content:center; }
.vs-col { flex: 1 1 280px; min-width: 260px; background: var(--card); border: 1px solid var(--accent); border-radius: 10px; padding: 10px; }
.vs-title { font-weight: 700; margin-bottom: 6px; }
.vs-chip { display:inline-block; margin: 2px; padding: 3px 8px; border-radius: 12px; color:#fff; font-weight:600; font-size:.85rem; }

/* Team coverage */
.team-wrap { display:flex; flex-direction:column; gap:12px; align-items:center; }
.team-bar { display:flex; gap:6px; flex-wrap:wrap; justify-content:center; }
.team-slot {
  display:flex; align-items:center; gap:8px;
  background: var(--card); border:1px solid var(--accent); border-radius:8px; padding:6px 8px;
}
.team-slot img { width:44px; height:44px; object-fit:contain; }
.team-slot .rm { background:none; border:1px solid var(--accent); color:var(--accent); padding:4px 6px; border-radius:6px; cursor:pointer; }
.team-actions { display:flex; gap:8px; flex-wrap:wrap; justify-content:center; }
.coverage-row { display:flex; gap:6px; flex-wrap:wrap; justify-content:center; }
.coverage-badge {
  display:inline-block; border-radius: 12px; padding:4px 8px; color:#fff; font-weight:700; font-size:.85rem;
}
.coverage-title { font-weight: 700; margin-top: 6px; text-align:center; }

/* Responsive tweaks */
@media(min-width: 860px){
  .home-grid { grid-template-columns: repeat(4, 1fr); }
  .poke-grid { grid-template-columns: repeat(6, 1fr); }
}

/* HOME-ONLY NAV (no top bar) */
#modeTabs { display: none !important; }

.home-btn {
  align-self: center;
  margin: 4px 0 8px;
  padding: 8px 12px;
  border-radius: 8px;
  border: 1px solid var(--accent);
  background: var(--card);
  color: var(--text);
  font-weight: 600;
  cursor: pointer;
}
.home-btn:hover {
  background: var(--accent);
  color: #000;
}

/* === MOVESET PANEL === */
.moves-panel {
  margin-top: 1rem;
  padding: 1rem;
  background: var(--card);
  border-radius: 10px;
  box-shadow: 0 0 8px rgba(255,191,0,0.25);
}

.moves-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  flex-wrap: wrap;
  margin-bottom: 0.5rem;
}

.moves-header select {
  padding: 6px 10px;
  border-radius: 6px;
  border: 1px solid var(--accent);
  background: var(--bg);
  color: var(--text);
  font-weight: 600;
}

.moves-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 0.9rem;
}

.moves-table th, .moves-table td {
  padding: 6px 8px;
  border-bottom: 1px solid rgba(255,255,255,0.1);
  text-align: left;
}

.moves-table th { color: var(--accent); }

.move-type-badge {
  display: inline-block;
  padding: 2px 6px;
  border-radius: 6px;
  font-size: 0.8em;
  margin-left: 6px;
  color: #fff;
  text-transform: capitalize;
}

.move-cat {
  display: inline-flex;
  align-items: center;
  gap: 4px;
}

.move-cat img {
  width: 16px;
  height: 16px;
}

/* side-by-side regular + shiny art */
#pokeArtWrap{
  display:flex;
  justify-content:center;
  align-items:center;
  gap:12px;
  flex-wrap:wrap;
}

</style>
</head>
<body>
<header>
  <h1>PokéType Checker</h1>
  <button id="themeToggle" title="Toggle Theme">☀️</button>
</header>

<div id="modeTabs">
  <div class="tab active" data-target="typeSection">Type Checker</div>
  <div class="tab" data-target="pokeSection">Pokémon Checker</div>
</div>

<main>
  <!-- TYPE SECTION (both perspectives) -->
  <section id="typeSection" class="section">
    <div id="typeControls">
      <label>Type 1:
        <select id="type1"></select>
      </label>
      <label>Type 2:
        <select id="type2">
          <option value="">(none)</option>
        </select>
      </label>
      <div id="typePreview"></div>
    </div>
    <div id="typeButtons">
      <button id="checkBtn">Check Effectiveness</button>
      <button id="resetBtn">Reset Types</button>
    </div>
    <div id="typeResults"></div>
  </section>

  <!-- POKÉMON SECTION (defense-only + evolution info) -->
  <section id="pokeSection" class="section">
    <div id="pokeControls">
      <input id="pokeSearch" placeholder="Search Pokémon name..." autocomplete="off" />
      <div id="pokeList"></div>
      <img id="pokeImg"
        src="icon-192.png"
        alt="Poké Ball placeholder"
        class="pulse">
      <div id="pokeTypes"></div>
      <div id="pokeButtonsRow">
        <button id="evoToggleBtn">Show Evolution Info</button>
        <button id="pokeResetBtn">Reset Pokémon</button>
      </div>
      <div id="evoCard" hidden>
        <div id="evoTitle" style="font-weight:700;margin-bottom:6px;">Evolution</div>
        <div id="evoContent"></div>
      </div>
    </div>
    <div id="pokeResults"></div>
  </section>
</main>

<script>
/* ---------- VERSION CONTROL & REFRESH BUTTON ---------- */
function showPokemonImage(url){
  const img = document.getElementById("pokeImg");
  img.src = url;
  img.classList.add("active");
  img.classList.remove("pulse");
}

function hidePokemonImage(){
  const img = document.getElementById("pokeImg");
  img.src = "icon-192.png";
  img.classList.remove("active");
  img.classList.add("pulse");
}
const appVersion = "1.4.0";
const refreshButton = document.createElement("button");
refreshButton.textContent = "🔄 Refresh App";
Object.assign(refreshButton.style, {
  position:"fixed", bottom:"10px", right:"10px", padding:"6px 10px",
  fontSize:"0.9rem", borderRadius:"8px", border:"1px solid var(--accent)",
  background:"var(--card)", color:"var(--accent)", zIndex:"9999"
});
refreshButton.onclick = () => {
  localStorage.removeItem("poketype-version");
  if ('caches' in window) caches.keys().then(keys => keys.forEach(k => caches.delete(k)));
  location.reload(true);
};
document.addEventListener("DOMContentLoaded", () => document.body.append(refreshButton));
const storedVersion = localStorage.getItem("poketype-version");
if (storedVersion && storedVersion !== appVersion) {
  if ('caches' in window) caches.keys().then(keys => keys.forEach(k => caches.delete(k)));
  localStorage.setItem("poketype-version", appVersion);
  location.reload(true);
} else if (!storedVersion) {
  localStorage.setItem("poketype-version", appVersion);
}

/* ---------- TYPE DATA ---------- */
const typeChart={
Normal:{weak:["Fighting"],resist:[],immune:["Ghost"]},
Fire:{weak:["Water","Ground","Rock"],resist:["Fire","Grass","Ice","Bug","Steel","Fairy"],immune:[]},
Water:{weak:["Electric","Grass"],resist:["Fire","Water","Ice","Steel"],immune:[]},
Electric:{weak:["Ground"],resist:["Electric","Flying","Steel"],immune:[]},
Grass:{weak:["Fire","Ice","Poison","Flying","Bug"],resist:["Water","Electric","Grass","Ground"],immune:[]},
Ice:{weak:["Fire","Fighting","Rock","Steel"],resist:["Ice"],immune:[]},
Fighting:{weak:["Flying","Psychic","Fairy"],resist:["Bug","Rock","Dark"],immune:[]},
Poison:{weak:["Ground","Psychic"],resist:["Grass","Fighting","Poison","Bug","Fairy"],immune:[]},
Ground:{weak:["Water","Grass","Ice"],resist:["Poison","Rock"],immune:["Electric"]},
Flying:{weak:["Electric","Ice","Rock"],resist:["Grass","Fighting","Bug"],immune:["Ground"]},
Psychic:{weak:["Bug","Ghost","Dark"],resist:["Fighting","Psychic"],immune:[]},
Bug:{weak:["Fire","Flying","Rock"],resist:["Grass","Fighting","Ground"],immune:[]},
Rock:{weak:["Water","Grass","Fighting","Ground","Steel"],resist:["Normal","Fire","Poison","Flying"],immune:[]},
Ghost:{weak:["Ghost","Dark"],resist:["Poison","Bug"],immune:["Normal","Fighting"]},
Dragon:{weak:["Ice","Dragon","Fairy"],resist:["Fire","Water","Electric","Grass"],immune:[]},
Dark:{weak:["Fighting","Bug","Fairy"],resist:["Ghost","Dark"],immune:["Psychic"]},
Steel:{weak:["Fire","Fighting","Ground"],resist:["Normal","Grass","Ice","Flying","Psychic","Bug","Rock","Dragon","Steel","Fairy"],immune:["Poison"]},
Fairy:{weak:["Poison","Steel"],resist:["Fighting","Bug","Dark"],immune:["Dragon"]}
};
const typeColors={Normal:"#A8A77A",Fire:"#EE8130",Water:"#6390F0",Electric:"#F7D02C",Grass:"#7AC74C",
Ice:"#96D9D6",Fighting:"#C22E28",Poison:"#A33EA1",Ground:"#E2BF65",Flying:"#A98FF3",
Psychic:"#F95587",Bug:"#A6B91A",Rock:"#B6A136",Ghost:"#735797",Dragon:"#6F35FC",
Dark:"#705746",Steel:"#B7B7CE",Fairy:"#D685AD"};
// add lowercase lookup so "fire" matches your "Fire" colors
const typeColorsLower = Object.fromEntries(
  Object.entries(typeColors).map(([k, v]) => [k.toLowerCase(), v])
);
const types=Object.keys(typeChart);
const t1=document.getElementById("type1"),t2=document.getElementById("type2");

/* Fill dropdowns (desktop shows colored options; mobile shows preview bars) */
function addTypeOptions(sel){
  types.forEach(t=>{
    const opt=new Option(t,t);
    opt.style.background=typeColors[t];
    opt.style.color="#fff";
    opt.style.fontWeight="600";
    sel.add(opt);
  });
}
addTypeOptions(t1); addTypeOptions(t2);

/* Tabs */
document.querySelectorAll(".tab").forEach(tab=>{
  tab.onclick=()=>{
    document.querySelectorAll(".tab").forEach(t=>t.classList.remove("active"));
    document.querySelectorAll(".section").forEach(s=>s.classList.remove("active"));
    tab.classList.add("active");
    document.getElementById(tab.dataset.target).classList.add("active");
  };
});

/* Theme toggle */
let lightTheme=false;
const themeBtn=document.getElementById("themeToggle");
themeBtn.onclick=()=>{
  lightTheme=!lightTheme;
  document.documentElement.style.setProperty("--bg",lightTheme?"#fff":"#0a1224");
  document.documentElement.style.setProperty("--card",lightTheme?"#f4f4f4":"#15254b");
  document.documentElement.style.setProperty("--text",lightTheme?"#000":"#fff");
  themeBtn.textContent = lightTheme ? "🌙" : "☀️";
};

/* Preview bars under selects (mobile-friendly) */
function updateTypePreview(){
  const preview=document.getElementById("typePreview");
  preview.innerHTML="";
  [t1.value,t2.value].filter(Boolean).forEach(t=>{
    const div=document.createElement("div");
    div.className="type-preview-badge";
    div.style.background=typeColors[t];
    preview.append(div);
  });
}
t1.onchange=updateTypePreview; t2.onchange=updateTypePreview;

/* Reset types */
document.getElementById("resetBtn").onclick=()=>{
  t1.selectedIndex=0; t2.selectedIndex=0;
  document.getElementById("typeResults").innerHTML="";
  updateTypePreview();
};

/* Calculations */
function calcOffense(selTypes){
  const all=Object.keys(typeChart); const result={strong:[],weak:[],immune:[]};
  all.forEach(def=>{
    let mult=1;
    selTypes.forEach(atk=>{
      if(typeChart[def].weak.includes(atk)) mult*=2;
      if(typeChart[def].resist.includes(atk)) mult*=0.5;
      if(typeChart[def].immune.includes(atk)) mult*=0;
    });
    if(mult>1) result.strong.push({type:def,mult});
    if(mult<1&&mult>0) result.weak.push({type:def,mult});
    if(mult===0) result.immune.push({type:def,mult});
  });
  return result;
}
function calcDefense(selTypes){
  const all=Object.keys(typeChart); const result={strong:[],weak:[],immune:[]};
  all.forEach(atk=>{
    let mult=1;
    selTypes.forEach(def=>{
      if(typeChart[def].weak.includes(atk)) mult*=2;
      if(typeChart[def].resist.includes(atk)) mult*=0.5;
      if(typeChart[def].immune.includes(atk)) mult*=0;
    });
    if(mult>1) result.strong.push({type:atk,mult});
    if(mult<1&&mult>0) result.weak.push({type:atk,mult});
    if(mult===0) result.immune.push({type:atk,mult});
  });
  return result;
}

/* Renderers */
function renderBoth(container,label,defense,offense){
  container.innerHTML="";
  const make=(l,d)=>{
    if(!d.length) return "";
    let html=`<div class='resultCard'><strong>${l}</strong><br>`;
    d.forEach(o=>{ html+=`<span class='type-badge' style='background:${typeColors[o.type]}'>${o.type} ×${o.mult}</span>`; });
    return html+"</div>";
  };
  container.innerHTML+=make(`Strong Against ${label}`,defense.strong);
  container.innerHTML+=make(`Not Very Effective Against ${label}`,defense.weak);
  container.innerHTML+=make(`No Effect Against ${label}`,defense.immune);
  container.innerHTML+=`<div class='section-divider'>Counter Perspective ▼</div>`;
  container.innerHTML+=make(`${label} is Strong Against`,offense.strong);
  container.innerHTML+=make(`${label} is Weak Against`,offense.weak);
  container.innerHTML+=make(`${label} has No Effect On`,offense.immune);
}
function renderDefenseOnly(container,label,defense){
  container.innerHTML="";
  const make=(l,d)=>{
    if(!d.length) return "";
    let html=`<div class='resultCard'><strong>${l}</strong><br>`;
    d.forEach(o=>{ html+=`<span class='type-badge' style='background:${typeColors[o.type]}'>${o.type} ×${o.mult}</span>`; });
    return html+"</div>";
  };
  container.innerHTML+=make(`Strong Against ${label}`,defense.strong);
  container.innerHTML+=make(`Not Very Effective Against ${label}`,defense.weak);
  container.innerHTML+=make(`No Effect Against ${label}`,defense.immune);
}

/* Type check */
document.getElementById("checkBtn").onclick=()=>{
  const sel=[t1.value,t2.value].filter(Boolean);
  if(!sel.length) return;
  const label=sel.join(" / ");
  const def=calcDefense(sel), off=calcOffense(sel);
  renderBoth(document.getElementById("typeResults"),label,def,off);
};

/* Pokémon search + images */
const pokeInput=document.getElementById("pokeSearch"),
      pokeList=document.getElementById("pokeList");
let pokedata=[];
async function loadData(){
  if(pokedata.length) return;
  const res=await fetch("https://raw.githubusercontent.com/fanzeyi/pokemon.json/master/pokedex.json");
  const list=await res.json();
  pokedata=list.map(p=>({name:p.name.english,types:p.type,id:p.id}));
}
pokeInput.addEventListener("input",async()=>{
  await loadData();
  const q=pokeInput.value.toLowerCase();
  pokeList.innerHTML="";
  if(!q) return;
  pokedata.filter(p=>p.name.toLowerCase().includes(q)).slice(0,10).forEach(p=>{
    const div=document.createElement("div");
    div.textContent=p.name; div.style.cursor="pointer";
    div.onclick=()=>selectPoke(p);
    pokeList.append(div);
  });
});

/* Evolution via PokéAPI */
async function fetchSpeciesById(id){
  const res=await fetch(`https://pokeapi.co/api/v2/pokemon-species/${id}/`);
  if(!res.ok) throw new Error("species fetch failed");
  return res.json();
}
async function fetchEvolutionChain(url){
  const res=await fetch(url);
  if(!res.ok) throw new Error("evo chain fetch failed");
  return res.json();
}
function extractIdFromUrl(url){
  const m=url.match(/\/(\d+)\/?$/); return m?parseInt(m[1],10):null;
}
function buildPaths(chain){
  const paths=[];
  function dfs(node, path){
    const id=extractIdFromUrl(node.species.url);
    const current=[...path, { name:node.species.name, id, details:node.evolution_details||[] }];
    if(!node.evolves_to || node.evolves_to.length===0){ paths.push(current); return; }
    node.evolves_to.forEach(next=>dfs(next, current));
  }
  dfs(chain, []);
  return paths;
}
function formatMethod(details){
  if(!details || !details[0]) return "";
  const d=details[0];
  if(d.trigger && d.trigger.name==="trade") return "Trade";
  if(d.trigger && d.trigger.name==="use-item" && d.item) return `Use ${title(d.item.name)}`;
  if(d.trigger && d.trigger.name==="level-up"){
    let bits=[];
    if(d.min_level!=null) bits.push(`Lv ${d.min_level}`);
    if(d.time_of_day) bits.push(title(d.time_of_day));
    if(d.min_happiness!=null) bits.push(`Happiness ${d.min_happiness}+`);
    if(d.known_move_type) bits.push(`${title(d.known_move_type.name)} move`);
    if(d.gender===1) bits.push("♀"); else if(d.gender===2) bits.push("♂");
    if(d.location) bits.push(`@ ${title(d.location.name)}`);
    return bits.join(" · ") || "Level up";
  }
  return title(d.trigger?.name||"");
}
function title(s){ return s.replace(/-/g," ").replace(/\b\w/g,c=>c.toUpperCase()); }
function evoImgUrl(id){ return `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/other/official-artwork/${id}.png`; }

function renderEvolution(paths){
  const container=document.getElementById("evoContent");
  container.innerHTML="";
  paths.forEach(path=>{
    const line=document.createElement("div"); line.className="evo-line";
    path.forEach((node, idx)=>{
      const nodeDiv=document.createElement("div");
      nodeDiv.className="evo-node";
      nodeDiv.innerHTML=`<img src="${evoImgUrl(node.id)}" alt="${node.name}"><div class="evo-name">${title(node.name)}</div>`;
      nodeDiv.onclick=()=>selectPokeById(node.id);
      line.append(nodeDiv);
      if(idx<path.length-1){
        const next=path[idx+1];
        const arrow=document.createElement("div"); arrow.className="evo-arrow"; arrow.textContent="→";
        const method=document.createElement("div"); method.className="evo-method"; method.textContent=formatMethod(next.details);
        const wrap=document.createElement("div"); wrap.style.display="flex"; wrap.style.flexDirection="column"; wrap.style.alignItems="center";
        wrap.append(arrow); wrap.append(method);
        line.append(wrap);
      }
    });
    container.append(line);
  });
}

/* Evo UI toggle */
const evoToggle=document.getElementById("evoToggleBtn");
let lastSelectedId=null;
evoToggle.onclick=async()=>{
  const card=document.getElementById("evoCard");
  if(card.hidden){
    if(!lastSelectedId){ alert("Pick a Pokémon first."); return; }
    await loadEvolutionForId(lastSelectedId);
    card.hidden=false; evoToggle.textContent="Hide Evolution Info";
  } else {
    card.hidden=true; evoToggle.textContent="Show Evolution Info";
  }
};
async function loadEvolutionForId(id){
  try{
    const species=await fetchSpeciesById(id);
    const evo=await fetchEvolutionChain(species.evolution_chain.url);
    const paths=buildPaths(evo.chain);
    renderEvolution(paths);
    document.getElementById("evoTitle").textContent=`Evolution — ${title(species.name)}`;
  }catch(e){
    document.getElementById("evoContent").innerHTML="<em>Could not load evolution data.</em>";
  }
}

/* Select Pokémon */
async function selectPoke(p) {
  lastSelectedId = p.id;
  document.getElementById("evoCard").hidden = true;
  evoToggle.textContent = "Show Evolution Info";

  pokeList.innerHTML = "";
  pokeInput.value = p.name;
  document.getElementById("pokeTypes").innerHTML = "";

  // Hide pulsing Poké Ball placeholder and show Pokémon artwork
  const img = document.getElementById("pokeImg");
  img.classList.remove("pulse");
  img.classList.add("active");
  img.src = `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/other/official-artwork/${p.id}.png`;

  // Display Pokémon type badges
  p.types.forEach(t => {
    const b = document.createElement("span");
    b.className = "type-badge";
    b.textContent = t;
    b.style.background = typeColors[t];
    document.getElementById("pokeTypes").append(b);
  });

  // Calculate and display defense info
  const def = calcDefense(p.types);
  renderDefenseOnly(document.getElementById("pokeResults"), p.name, def);

  // Sync Type tab and show both views
  t1.value = p.types[0];
  t2.value = p.types[1] || "";
  updateTypePreview();
  const label = p.types.join(" / ");
  const off = calcOffense(p.types);
  renderBoth(document.getElementById("typeResults"), label, def, off);
}

async function selectPokeById(id){
  await loadData();
  const found=pokedata.find(x=>x.id===id);
  if(found){ selectPoke(found); return; }
  const res=await fetch(`https://pokeapi.co/api/v2/pokemon/${id}/`);
  const j=await res.json();
  const types=j.types.map(t=>title(t.type.name));
  const name=title(j.name);
  selectPoke({id,name,types});
}

/* Pokémon reset */
document.getElementById("pokeResetBtn").onclick=()=>{
  pokeInput.value="";
  document.getElementById("pokeList").innerHTML="";
  document.getElementById("pokeTypes").innerHTML="";
  document.getElementById("pokeResults").innerHTML="";
  hidePokemonImage(); // <-- restore pulsing Poké Ball placeholder
  document.getElementById("evoCard").hidden=true;
  evoToggle.textContent="Show Evolution Info";
};

/* Type check button (again here to ensure binding) */
document.getElementById("checkBtn").onclick=()=>{
  const sel=[t1.value,t2.value].filter(Boolean);
  if(!sel.length) return;
  const label=sel.join(" / "); const def=calcDefense(sel), off=calcOffense(sel);
  renderBoth(document.getElementById("typeResults"),label,def,off);
};

/* PWA registration only over http(s) */
if("serviceWorker" in navigator && location.protocol.startsWith("http")){
  navigator.serviceWorker.register("sw.js");
}

/* === NEW FEATURES JS (append at end) === */
/* This code assumes your existing variables/functions:
   - types, typeColors, typeChart
   - calcDefense(selTypes), calcOffense(selTypes)
   - loadData(), pokedata, selectPoke(p), selectPokeById(id)
   - title(s) helper (if you have it; fallback inline if not)
*/

/* ---------- Helper: title-case fallback if missing ---------- */
if (typeof title !== "function") {
  var title = (s) => s.replace(/-/g," ").replace(/\b\w/g, c => c.toUpperCase());
}

/* ---------- Helper: images ---------- */
function artUrl(id){
  return `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/other/official-artwork/${id}.png`;
}

/* ---------- Helper: multiplier from one attacking type vs defender types ---------- */
function multAtkVsDefType(atk, defTypes){
  let mult = 1;
  defTypes.forEach(def=>{
    if (typeChart[def].weak.includes(atk))   mult *= 2;
    if (typeChart[def].resist.includes(atk)) mult *= 0.5;
    if (typeChart[def].immune.includes(atk)) mult *= 0;
  });
  return mult;
}

/* ---------- Best attack from a set of attacker types vs defender types ---------- */
function bestAttack(attackerTypes, defenderTypes){
  let best = {mult: 1, types: []};
  attackerTypes.forEach(atk=>{
    const m = multAtkVsDefType(atk, defenderTypes);
    if (m > best.mult) { best = {mult: m, types: [atk]}; }
    else if (m === best.mult) { best.types.push(atk); }
  });
  // unique
  best.types = [...new Set(best.types)];
  return best;
}

// === GLOBAL TEAM STORAGE ===
const TEAM_KEY = "poketype-team-v1";
let team = [];

function saveTeam() {
  localStorage.setItem(TEAM_KEY, JSON.stringify(team));
}
function loadTeam() {
  try {
    const raw = localStorage.getItem(TEAM_KEY);
    const parsed = JSON.parse(raw);
    team = Array.isArray(parsed) ? parsed : [];
  } catch (e) {
    team = [];
  }
}

/* ---------- Tabs: make a new Home tab + three feature tabs/sections ---------- */
(function injectFeatureTabs(){
  const tabsWrap = document.getElementById("modeTabs");
  const main = document.querySelector("main");
  if (!tabsWrap || !main) return;

  // Avoid duplicate injection
  if (document.getElementById("homeSection")) return;

  // Build tabs
  const mkTab = (txt, targetId) => {
    const div = document.createElement("div");
    div.className = "tab";
    div.dataset.target = targetId;
    div.textContent = txt;
    return div;
  };

  const homeTab   = mkTab("Home",      "homeSection");
  const comboTab  = mkTab("Type Combo","comboSection");
  const vsTab     = mkTab("Matchup VS","vsSection");
  const teamTab   = mkTab("Team",      "teamSection");

  // Insert Home at the front
  tabsWrap.prepend(homeTab);
  tabsWrap.append(comboTab, vsTab, teamTab);

  // Sections
  const home = document.createElement("section");
  home.id = "homeSection";
  home.className = "section";
  home.innerHTML = `
    <div class="resultCard">
      <div class="home-grid">
        <div class="home-card" data-go="typeSection">
          <div class="title">Type Checker</div>
          <div class="desc">Pick a type or pair to explore counters and coverage.</div>
        </div>
        <div class="home-card" data-go="pokeSection">
          <div class="title">Pokémon Checker</div>
          <div class="desc">Look up a Pokémon’s weaknesses and evolution line.</div>
        </div>
        <div class="home-card" data-go="comboSection">
          <div class="title">Type Combo Search</div>
          <div class="desc">Find Pokémon with a single or dual typing.</div>
        </div>
        <div class="home-card" data-go="vsSection">
          <div class="title">Matchup (VS)</div>
          <div class="desc">Compare two Pokémon for type advantage.</div>
        </div>
        <div class="home-card" data-go="teamSection">
          <div class="title">Team Coverage</div>
          <div class="desc">Build a team and see weaknesses & coverage.</div>
        </div>
      </div>
    </div>
  `;

  const combo = document.createElement("section");
  combo.id = "comboSection";
  combo.className = "section";
  combo.innerHTML = `
    <div class="resultCard tool-wrap">
      <div class="tool-row">
        <select id="comboType1" class="tool-wide"></select>
        <select id="comboType2" class="tool-wide">
          <option value="">(none)</option>
        </select>
      </div>
      <div class="tool-row">
        <button id="comboSearchBtn">Search</button>
        <button id="comboClearBtn">Clear</button>
      </div>
      <div id="comboResults" class="poke-grid"></div>
    </div>
  `;

  const vs = document.createElement("section");
  vs.id = "vsSection";
  vs.className = "section";
  vs.innerHTML = `
    <div class="resultCard">
      <div class="vs-wrap">
        <div class="vs-col">
          <div class="vs-title">Pokémon A</div>
          <input id="vsAInput" placeholder="Search Pokémon A..." class="tool-wide" autocomplete="off">
          <div id="vsAList"></div>
          <div id="vsASummary"></div>
        </div>
        <div class="vs-col">
          <div class="vs-title">Pokémon B</div>
          <input id="vsBInput" placeholder="Search Pokémon B..." class="tool-wide" autocomplete="off">
          <div id="vsBList"></div>
          <div id="vsBSummary"></div>
        </div>
      </div>
    </div>
  `;

  const teamSection = document.createElement("section");
  teamSection.id = "teamSection";
  teamSection.className = "section";
  teamSection.innerHTML = `
    <div class="resultCard team-wrap">
      <input id="teamInput" placeholder="Add Pokémon to team..." class="tool-wide" autocomplete="off">
      <div id="teamSuggest"></div>
      <div id="teamSlots" class="team-bar"></div>
      <div class="team-actions">
        <button id="saveTeamBtn">Save Team</button>
        <button id="clearTeamBtn">Clear Team</button>
      </div>
      <div class="resultCard" id="teamDefense"></div>
      <div class="resultCard" id="teamOffense"></div>
    </div>
  `;

  // Put Home first
  const firstOld = document.getElementById("typeSection");
  main.prepend(home);
  main.append(combo, vs, teamSection);

  // Home navigation
  home.querySelectorAll(".home-card").forEach(card=>{
    card.onclick = () => {
      const target = card.getAttribute("data-go");
      switchTab(target);
    };
  });

  // Extend tab behavior to include the new tabs
  [homeTab, comboTab, vsTab, teamTab].forEach(tab=>{
    tab.onclick = () => switchTab(tab.dataset.target);
  });

  // Helper to switch tabs/sections
  function switchTab(targetId){
    document.querySelectorAll(".tab").forEach(t=>t.classList.remove("active"));
    document.querySelectorAll(".section").forEach(s=>s.classList.remove("active"));
    const tab = [...document.querySelectorAll(".tab")].find(t=>t.dataset.target===targetId);
    if (tab) tab.classList.add("active");
    const sec = document.getElementById(targetId);
    if (sec) sec.classList.add("active");
  }

  // Fill combo selects with type options
  function fillTypeOptions(sel){
    types.forEach(t=>{
      const opt = new Option(t,t);
      opt.style.background = typeColors[t];
      opt.style.color = "#fff";
      opt.style.fontWeight = "600";
      sel.add(opt);
    });
  }
  fillTypeOptions(combo.querySelector("#comboType1"));
  fillTypeOptions(combo.querySelector("#comboType2"));

  /* ---------- TYPE COMBO SEARCH ---------- */
  const comboType1 = document.getElementById("comboType1");
  const comboType2 = document.getElementById("comboType2");
  const comboResults = document.getElementById("comboResults");
  document.getElementById("comboSearchBtn").onclick = async ()=>{
    await loadData();
    const a = comboType1.value;
    const b = comboType2.value;
    if (!a && !b) { comboResults.innerHTML = ""; return; }
    const match = pokedata.filter(p=>{
      if (b) {
        // dual type (any order)
        return p.types.length===2 && ((p.types[0]===a&&p.types[1]===b)||(p.types[0]===b&&p.types[1]===a));
      }
      // single type match (any slot)
      return p.types.includes(a);
    }).slice(0, 200);
    comboResults.innerHTML = "";
    match.forEach(p=>{
      const card = document.createElement("div");
      card.className = "poke-card";
      card.innerHTML = `<img src="${artUrl(p.id)}"><div class="nm">${p.name}</div>`;
      card.onclick = () => {
        window.switchTab("pokeSection");
        selectPoke(p);
        };
      comboResults.append(card);
    });
  };
  document.getElementById("comboClearBtn").onclick = ()=>{ comboType1.selectedIndex = 0; comboType2.selectedIndex = 0; comboResults.innerHTML = ""; };

  /* ---------- MATCHUP (VS) ---------- */
  const vsAInput = document.getElementById("vsAInput");
  const vsBInput = document.getElementById("vsBInput");
  const vsAList = document.getElementById("vsAList");
  const vsBList = document.getElementById("vsBList");
  const vsASummary = document.getElementById("vsASummary");
  const vsBSummary = document.getElementById("vsBSummary");
  let vsA=null, vsB=null;

  async function suggestInto(input, list, setter){
    await loadData();
    const q = input.value.toLowerCase();
    list.innerHTML = "";
    if (!q) return;
    pokedata.filter(p=>p.name.toLowerCase().includes(q)).slice(0,12).forEach(p=>{
      const div = document.createElement("div");
      div.textContent = p.name;
      div.style.cursor = "pointer";
      div.onclick = ()=>{ setter(p); list.innerHTML=""; input.value=p.name; };
      list.append(div);
    });
  }
  vsAInput.addEventListener("input",()=>suggestInto(vsAInput, vsAList, p=>{vsA=p; renderVS();}));
  vsBInput.addEventListener("input",()=>suggestInto(vsBInput, vsBList, p=>{vsB=p; renderVS();}));

  function renderVS(){
    vsASummary.innerHTML = "";
    vsBSummary.innerHTML = "";
    if (!vsA || !vsB) return;

    const aBest = bestAttack(vsA.types, vsB.types); // A's best move vs B
    const bBest = bestAttack(vsB.types, vsA.types); // B's best move vs A

    const mk = (who, self, opp, best) => {
      const box = who==="A" ? vsASummary : vsBSummary;
      const head = document.createElement("div");
      head.className = "vs-title";
      head.textContent = `${self.name} → ${opp.name}`;
      const row = document.createElement("div");
      row.className = "coverage-row";
      best.types.forEach(t=>{
        const span = document.createElement("span");
        span.className = "vs-chip";
        span.style.background = typeColors[t];
        span.textContent = `${t} ×${best.mult}`;
        row.append(span);
      });
      box.append(head, row);
    };
    mk("A", vsA, vsB, aBest);
    mk("B", vsB, vsA, bBest);
  }

  /* ---------- TEAM COVERAGE ---------- */
  const teamInput = document.getElementById("teamInput");
  const teamSuggest = document.getElementById("teamSuggest");
  const teamSlots = document.getElementById("teamSlots");
  const teamDefense = document.getElementById("teamDefense");
  const teamOffense = document.getElementById("teamOffense");

  async function teamSuggestHandler(){
    await loadData();
    const q = teamInput.value.toLowerCase();
    teamSuggest.innerHTML = "";
    if (!q) return;
    pokedata.filter(p=>p.name.toLowerCase().includes(q)).slice(0,12).forEach(p=>{
      const d = document.createElement("div");
      d.textContent = p.name;
      d.style.cursor = "pointer";
      d.onclick = ()=>{ addToTeam(p); teamSuggest.innerHTML=""; teamInput.value=""; };
      teamSuggest.append(d);
    });
  }
  teamInput.addEventListener("input", teamSuggestHandler);

  function addToTeam(p){
    if (team.length >= 6) return;
    // avoid dup by id
    if (team.some(x=>x.id===p.id)) return;
    team.push({id:p.id, name:p.name, types:p.types});
    renderTeam();
  }
  function removeFromTeam(id){
    team = team.filter(x=>x.id!==id);
    renderTeam();
  }

  function renderTeam(){
    if (!Array.isArray(team)) team = [];
    // slots
    teamSlots.innerHTML = "";
    team.forEach(p=>{
      const slot = document.createElement("div");
      slot.className = "team-slot";
      slot.innerHTML = `<img src="${artUrl(p.id)}"><div>${p.name}</div>`;
      const rm = document.createElement("button");
      rm.className = "rm"; rm.textContent = "Remove";
      rm.onclick = ()=>removeFromTeam(p.id);
      slot.append(rm);
      teamSlots.append(slot);
    });

    // defense: for each attack type, count how many mons are weak/resist/immune
    const atkTypes = Object.keys(typeChart);
    const counts = atkTypes.map(atk=>{
      let weak=0,res=0,imm=0;
      team.forEach(mon=>{
        const m = multAtkVsDefType(atk, mon.types);
        if (m>1) weak++;
        else if (m===0) imm++;
        else if (m<1) res++;
      });
      return {atk, weak, res, imm};
    });
    counts.sort((a,b)=>b.weak - a.weak); // top threats first

    teamDefense.innerHTML = `<div class="coverage-title">Team Defense: Top Threats</div>`;
    const defRow = document.createElement("div");
    defRow.className = "coverage-row";
    counts.slice(0,8).forEach(c=>{
      const badge = document.createElement("span");
      badge.className = "coverage-badge";
      badge.style.background = typeColors[c.atk];
      badge.textContent = `${c.atk}: ${c.weak} weak / ${c.res} resist / ${c.imm} immune`;
      defRow.append(badge);
    });
    teamDefense.append(defRow);

    // offense: which defender types are covered by at least one team type
    const defTypes = Object.keys(typeChart);
    const covered = new Set();
    team.forEach(mon=>{
      defTypes.forEach(def=>{
        const m = bestAttack(mon.types, [def]).mult; // mono-def for coverage
        if (m>1) covered.add(def);
      });
    });
    const uncovered = defTypes.filter(d=>!covered.has(d));

    teamOffense.innerHTML = `<div class="coverage-title">Team Offense: Coverage Map</div>`;
    const offRow1 = document.createElement("div");
    offRow1.className = "coverage-row";
    covered.forEach(d=>{
      const b = document.createElement("span");
      b.className = "coverage-badge";
      b.style.background = typeColors[d];
      b.textContent = d;
      offRow1.append(b);
    });
    const offRow2 = document.createElement("div");
    offRow2.className = "coverage-row";
    uncovered.forEach(d=>{
      const b = document.createElement("span");
      b.className = "coverage-badge";
      b.style.background = "#444";
      b.textContent = d;
      offRow2.append(b);
    });
    teamOffense.append(offRow1, offRow2);
  }

  // Buttons
  document.getElementById("saveTeamBtn").onclick = ()=>{ saveTeam(); };
  document.getElementById("clearTeamBtn").onclick = ()=>{ team = []; renderTeam(); saveTeam(); };

  // Initialize team from localStorage
  loadTeam(); renderTeam();
})();

/* === HOME-ONLY NAVIGATION (fixed timing) === */
(function setupHomeNavigation(){
  // Hide tab bar
  const tabs = document.getElementById("modeTabs");
  if (tabs) tabs.style.display = "none";

  // Global switch function
  window.switchTab = function(targetId){
    document.querySelectorAll(".section").forEach(s => s.classList.remove("active"));
    const sec = document.getElementById(targetId);
    if (sec) sec.classList.add("active");
  };

  // Helper to ensure a Home button exists at the top of each section
  function ensureHomeButtons(){
    ["typeSection","pokeSection","comboSection","vsSection","teamSection"].forEach(id=>{
      const sec = document.getElementById(id);
      if (sec && !sec.querySelector(".home-btn")) {
        const btn = document.createElement("button");
        btn.className = "home-btn";
        btn.textContent = "← Home";
        btn.onclick = () => window.switchTab("homeSection");
        sec.prepend(btn);
      }
    });
  }

  // Run once immediately (covers sections that already exist)
  ensureHomeButtons();

  // Also run whenever sections are injected/changed
  const observer = new MutationObserver(ensureHomeButtons);
  observer.observe(document.querySelector("main"), {childList:true, subtree:true});

  // Go to Home on startup
  window.switchTab("homeSection");
})();

/* === MOVES PANEL + SHINY + GENERATION SELECTOR === */

// Version-group → generation map
const versionGroupToGen = {
  "red-blue":1,"yellow":1,
  "gold-silver":2,"crystal":2,
  "ruby-sapphire":3,"emerald":3,"firered-leafgreen":3,
  "diamond-pearl":4,"platinum":4,"heartgold-soulsilver":4,
  "black-white":5,"black-2-white-2":5,
  "x-y":6,"omega-ruby-alpha-sapphire":6,
  "sun-moon":7,"ultra-sun-ultra-moon":7,
  "sword-shield":8,"brilliant-diamond-and-shining-pearl":8,
  "scarlet-violet":9
};

// Inject panel
(function setupMovesPanel(){
  const sec=document.getElementById("pokeSection");
  if(!sec) return;
  const div=document.createElement("div");
  div.className="moves-panel";
  div.innerHTML=`
    <div class="moves-header">
      <h3 style="margin:0;">Level-Up Moves</h3>
      <select id="genSelect">
        ${Array.from({length:9},(_,i)=>`<option value="${i+1}">Gen ${i+1}</option>`).join("")}
      </select>
    </div>
    <table class="moves-table" id="movesTable">
      <thead><tr><th>Lvl</th><th>Move</th><th>Type</th><th>Power</th><th>Category</th></tr></thead>
      <tbody><tr><td colspan="5">No data yet.</td></tr></tbody>
    </table>`;
  sec.appendChild(div);
})();

// Render shiny + fetch moves
async function showMoves(pName,pId){
  const genSelect=document.getElementById("genSelect");
  const tbody=document.querySelector("#movesTable tbody");
  if(!genSelect||!tbody) return;

  // Ensure both regular and shiny sit side-by-side
const img = document.getElementById("pokeImg");

// Build a wrapper once and move the existing image into it
let wrap = document.getElementById("pokeArtWrap");
if (!wrap) {
  wrap = document.createElement("div");
  wrap.id = "pokeArtWrap";
  img.parentNode.insertBefore(wrap, img);
  wrap.appendChild(img); // move existing regular art into the wrapper
}

// Create (or reuse) the shiny image inside the same wrapper
let shiny = document.getElementById("pokeImgShiny");
if (!shiny) {
  shiny = document.createElement("img");
  shiny.id = "pokeImgShiny";
  shiny.style.width = "140px";
  shiny.style.opacity = "1";
  shiny.style.transition = "opacity .3s ease";
  wrap.appendChild(shiny);
}

// Set shiny artwork URL
shiny.src = `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/other/official-artwork/shiny/${pId}.png`;
shiny.hidden = false;


  const res=await fetch(`https://pokeapi.co/api/v2/pokemon/${pId}`);
  const data=await res.json();

  async function render(gen){
    const lvlMoves=data.moves.map(m=>{
      const det=m.version_group_details.find(vgd=>
        versionGroupToGen[vgd.version_group.name]===gen &&
        vgd.move_learn_method.name==="level-up"
      );
      if(!det) return null;
      return {name:m.move.name,url:m.move.url,level:det.level_learned_at};
    }).filter(Boolean).sort((a,b)=>a.level-b.level);

    if(!lvlMoves.length){
      tbody.innerHTML=`<tr><td colspan="5">No level-up moves for Gen ${gen}.</td></tr>`;
      return;
    }

    const detailed=await Promise.all(lvlMoves.map(async m=>{
      try{
        const r=await fetch(m.url);const j=await r.json();
        return {
          name:m.name.replace(/-/g," "),
          level:m.level||"—",
          type:j.type.name,
          power:j.power??"—",
          cat:j.damage_class.name
        };
      }catch{return {...m,type:"unknown",power:"—",cat:"status"};}
    }));

    tbody.innerHTML=detailed.map(m=>{
      const color = typeColorsLower[m.type] || "#666";
      return `<tr>
        <td>${m.level}</td>
        <td style="text-transform:capitalize">${m.name}</td>
        <td><span class="move-type-badge" style="background:${color}">${m.type}</span></td>
        <td>${m.power}</td>
        <td style="text-transform:capitalize">${m.cat}</td>
      </tr>`;
    }).join("");
  }

  render(parseInt(genSelect.value));
  genSelect.onchange=()=>render(parseInt(genSelect.value));
}

// Hook into selectPoke
const oldSelectPoke=selectPoke;
selectPoke=async function(p){
  await oldSelectPoke(p);
  showMoves(p.name,p.id);
};

</script>
</body>
</html>
